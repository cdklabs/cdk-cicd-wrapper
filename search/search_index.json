{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"cli/index.html","title":"Index","text":"<p>TBD</p>"},{"location":"cli/cli_check_dependencies.html","title":"Check Dependencies","text":"<p>The <code>npx @cdklabs/cdk-cicd-wrapper-cli check-dependencies</code> audits dependencies.</p>"},{"location":"cli/cli_configure.html","title":"Configure","text":"<p>The <code>npx @cdklabs/cdk-cicd-wrapper-cli configure</code> script uses a series of prompts and user input to build a bash script that can be used to <code>source</code> your environment variables into your active shell/terminal. Additionally, the configure script sets values in the config section of the <code>package.json</code> file. The created <code>.env</code> can be modified or duplicated to assist developers moving between potentially different test environments.</p>"},{"location":"cli/cli_configure.html#cdk-cicd-wrapper-variables","title":"CDK CI/CD Wrapper Variables","text":"ENV Variable Package.json config Default Value Description AWS_REGION deployment region ACCOUNT_RES account id for resources account where pipeline will run ACCOUNT_DEV account id for DEV environment account ACCOUNT_INT account id for INT environment account RES_ACCOUNT_AWS_PROFILE sets the named profile to use for the RES account. this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> DEV_ACCOUNT_AWS_PROFILE sets the named profile to use for the DEV account. this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> INT_ACCOUNT_AWS_PROFILE sets the named profile to use for the INT account. this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> AWS_PROFILE sets the default named profile to use for aws cli or cdk commands when no <code>--profile</code> is provided. set to the same value as <code>RES_ACCOUNT_AWS_PROFILE</code> this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> applicationName Wrapper sets the name of the Application CDK_QUALIFIER cdkQualifier wrapper used to distinguish between multiple deployments of a VP project in the same account. Good practice to customize per deployment. GIT_REPOSITORY repositoryName sets the name of the Git repository in the format org/name repositoryType sets the type of the repository, <code>GITHUB</code> or <code>CODECOMMIT</code> CODESTAR_CONNECTION_ARN sets the codestar connection required for GITHUB type CICD_VPC_TYPE cicdVpcType NO_VPC sets the type of the VPC: <code>NO_VPC</code>, <code>VPC</code>, or <code>VPC_FROM_LOOK_UP</code>. CICD_VPC_ID cicdVpcId for use with <code>VPC_FROM_LOOK_UP</code> to set the vpc ID CICD_VPC_CIDR cicdVpcCidr 172.31.0.0/20 for use with <code>VPC</code> to set the CIDR block of the VPC CICD_VPC_CIDR_MASK cicdVpcCidrMask 24 for use with <code>VPC</code> to set the Subnet size PROXY_SECRET_ARN used to set the ARN for the proxy secrets to enable proxy WORKBENCH_STAGE used to test the CDK Stacks in a given stage, by default is DEV"},{"location":"cli/cli_license.html","title":"License Management","text":"<p>The <code>npx @cdklabs/cdk-cicd-wrapper-cli license</code> can validate and generate a NOTICE file for the project.</p> <p>The NOTICE file consistency is tested by the <code>npx @cdklabs/cdk-cicd-wrapper-cli license</code>, this script is included into the CodePipeline Build step to ensure the NOTICE file is always up-to-date.</p> <p>The script checks dependencies in <code>package.json</code> for NPM, <code>Pipfile.lock</code>, and <code>requirements.txt</code> for Python projects. In case, you are using other package managers, you need to manage those dependencies by yourself as long as that is not supported by CDK CI/CD Wrapper.</p> <p>The used dependencies can be dependent on the Operating System and the runtime environment so for this reason the generated NOTICE file could be different based on which environment is generated. Our tool persists the state of the project files which hold information about 3rd party dependencies in the <code>package-verification.json</code> file. If those files are not modified or a new file hasn't been added or previously existing files haven't been removed the tool considers the NOTICE file as up to date. In this situation you want to forcefully regenerate the NOTICE file you can do that with the <code>--force</code> parameter.</p> <p>To update the NOTICE file you need to run the following command:</p> <pre><code>npx @cdklabs/cdk-cicd-wrapper-cli license --fix\n</code></pre>"},{"location":"cli/cli_license.html#configuration-options","title":"Configuration options","text":"<p>The script configuration can be specified in the <code>licensecheck.json</code> file.</p> <p>Example configuration:</p> <pre><code>{\n  \"failOnLicenses\": [\"MIT License\"],\n  \"npm\": {\n    \"excluded\": [],\n    \"excludedSubProjects\": [\"./example/package.json\"]\n  },\n  \"python\": {\n    \"excluded\": [],\n    \"excludedSubProjects\": [\"./example/Pipfile\"]\n  }\n}\n</code></pre> <ul> <li>Banned licenses can be listed on the <code>failOnLicenses</code> attribute. The license name match is case sensitive.</li> <li>Sub folder which <code>Pipfile</code> or <code>package.json</code> file should not be included into the License check should be listen under the <code>npm.excludedSubProjects</code> or <code>python.excludedSubProjects</code> attributes.</li> <li>For NPM packages the subfolder also needs to contain a package-lock.json file to ensure the right dependencies will be installed and checked.</li> <li>Dependencies can be excluded from the license verification for NPM and Python as well.</li> </ul>"},{"location":"cli/cli_security_scan.html","title":"Security Scanning","text":"<p>The <code>npx @cdklabs/cdk-cicd-wrapper-cli security-scan</code> scans the codebase for security vulnerabilities.</p> <p>You can read more about the built-in Security functionalities.</p>"},{"location":"cli/cli_validate.html","title":"Validate","text":"<p>The <code>npx @cdklabs/cdk-cicd-wrapper-cli validate</code> ensures the package-lock.json file is not tempered with.</p>"},{"location":"contributing/index.html","title":"Contributing Guidelines","text":"<p>Thank you for your interest in contributing to the CDK CI/CD Wrapper. Whether it's a bug report, new feature, correction, or additional documentation, we greatly value feedback and contributions from our community.</p> <p>Please read through this document before submitting any issues or pull requests to ensure we have all the necessary information to effectively respond to your bug report or contribution.</p>"},{"location":"contributing/index.html#project-structure","title":"Project Structure","text":"<p>The structure of this project is as follows:</p> <pre><code>\u251c\u2500\u2500 docs                                  # Documentation \n\u251c\u2500\u2500 packages                              # Packages\n\u2502   \u2514\u2500\u2500 @cdklabs\n\u2502       \u251c\u2500\u2500 cdk-cicd-wrapper              # CDK CI/CD Wrapper Blueprint\n\u2502       \u2514\u2500\u2500 cdk-cicd-wrapper-cli          # CLI tools to support the Blueprint\n\u251c\u2500\u2500 projenrc                              # Projen source\n\u251c\u2500\u2500 samples                               # Samples folder for demonstrating various aspects of the tool\n\u251c\u2500\u2500 .projenrc.ts                          # Projen file to manage project structure\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 CODE_OF_CONDUCT.md\n\u251c\u2500\u2500 CONFIGVARS.md\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 NOTICE\n\u251c\u2500\u2500 OSS_License_Summary.csv\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 Taskfile.yml                          # Contains helpful tasks that are useful during development\n\u251c\u2500\u2500 bandit.yaml\n\u251c\u2500\u2500 licensecheck.json\n\u251c\u2500\u2500 package-verification.json\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.dev.json\n\u251c\u2500\u2500 tsconfig.json\n\u2514\u2500\u2500 yarn.lock\n</code></pre>"},{"location":"contributing/index.html#docs","title":"docs","text":"<p>This is where the documentation site is defined and built.</p>"},{"location":"contributing/index.html#packages","title":"packages","text":"<p>This folder the sources are located</p>"},{"location":"contributing/index.html#reporting-bugsfeature-requests","title":"Reporting Bugs/Feature Requests","text":"<p>We welcome you to use the GitHub issue tracker to report bugs or suggest features.</p> <p>When filing an issue, please check existing open, or recently closed, issues to make sure somebody else hasn't already reported the issue. Please try to include as much information as you can. Details like these are incredibly useful:</p> <ul> <li>A reproducible test case or series of steps</li> <li>The version of our code being used (semver)</li> <li>Any modifications you've made relevant to the bug</li> <li>Anything unusual about your environment or deployment</li> </ul>"},{"location":"contributing/index.html#contributing-via-pull-requests","title":"Contributing via Pull Requests","text":"<p>Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that:</p> <ol> <li>You are working against the latest source on the main branch.</li> <li>You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already.</li> <li>You open an issue to discuss any significant work - we would hate for your time to be wasted.</li> </ol> <p>To send us a pull request, please:</p> <ol> <li>Fork the repository.</li> <li>Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change.</li> <li>Run <code>task build</code> to ensure everything builds and tests correctly. <p>This will execute all necessary verification <code>verification</code>, <code>build</code>, <code>test</code>, <code>audit</code>.</p> </li> <li>Commit to your fork on a new branch using conventional commit messages.</li> <li>Send us a pull request, answering any default questions in the pull request template.</li> <li>Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation.</li> </ol> <p>GitHub provides additional documentation on forking a repository and creating a pull request.</p>"},{"location":"contributing/index.html#commit-messages","title":"Commit Messages","text":"<p>By default we have enabled the commit-msg hook via husky which comes installed by default when you first run <code>npm ci</code>. We are enforcing the convention described in conventionalcommits by default for the commit messages to help make the collaboration between team members transparent and consistent. If your commit messages do not follow this convention, you won't be able to commit your changes from your local machine. Check the example below: WRONG COMMIT MESSAGE</p> <pre><code>&gt; git commit -m \"foo: this will fail\"\n\n&gt; cdk-cicd-wrapper@1.2.3 commitlint\n&gt; commitlint --edit\n\n\u29d7   input: foo: this will fail\n\u2716   type must be one of [build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] [type-enum]\n\n\u2716   found 1 problems, 0 warnings\n\u24d8   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint\n\nhusky - commit-msg hook exited with code 1 (error)\n</code></pre> <p>CORRECT COMMIT MESSAGE</p> <pre><code>&gt; git commit -m \"docs: updated README.md with better instructions for the commit-msg hook\"\n\n&gt; cdk-cicd-wrapper@1.2.3 commitlint\n&gt; commitlint --edit .git/COMMIT_EDITMSG\n\n[feat/developer-tools 24192d7] docs: updated README.md with better instructions for the commit-msg hook\n 1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre>"},{"location":"contributing/index.html#commits","title":"Commits","text":"<p>This package utilizes conventional commits and as such all commit messages will need to adopt this format. A <code>commit-msg</code> hook is installed as part of this package to enforce correct commit message structure and will be run anytime a <code>git commit ...</code> is executed.</p> <p>Commitizen has been installed for your convenience which provides a guided UI for committing changes. To commit your changes run the following commands:</p> <pre><code>git add -A # stage your changes\nnpx cz # launch commitizen\n</code></pre> <p>An interactive UI will be displayed which you can follow to get your change committed.</p> <p>Package versioning is determined based on the semantic commit and as such it is very important this format is followed. A PR checker will also run to ensure the format of your commit message is compliant.</p>"},{"location":"contributing/index.html#finding-contributions-to-work-on","title":"Finding contributions to work on","text":"<p>Looking at the existing issues is a great way to find something to contribute on. As our projects, by default, use the default GitHub issue labels (enhancement/bug/duplicate/help wanted/invalid/question/wontfix), looking at any 'help wanted' issues is a great place to start.</p>"},{"location":"contributing/index.html#code-of-conduct","title":"Code of Conduct","text":"<p>This project has adopted the Amazon Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opensource-codeofconduct@amazon.com with any additional questions or comments.</p>"},{"location":"contributing/index.html#security-issue-notifications","title":"Security issue notifications","text":"<p>If you discover a potential security issue in this project we ask that you notify AWS/Amazon Security via our vulnerability reporting page. Please do not create a public github issue.</p>"},{"location":"contributing/index.html#licensing","title":"Licensing","text":"<p>See the LICENSE file for our project's licensing. We will ask you to confirm the licensing of your contribution.</p> <p>We may ask you to sign a Contributor License Agreement (CLA) for larger changes.</p>"},{"location":"contributing/index.html#working-with-documentation","title":"Working with documentation","text":"<p>The documentation for the CDK CI/CD Wrapper Core is stored under the docs/ (index file: index.md) and is designed to be viewed as an MkDocs html site. Before heading to the documentation we highly recommend you:</p> <p>test</p> <ul> <li>Run the build docs script <code>task docs</code> using you UNIX cli</li> <li>Start the local mkdocs webserver to view locally the ConfigBuilder documentation site with the <code>task docs:local</code> command; the documentation will then be available at http://localhost:8000</li> </ul>"},{"location":"contributing/index.html#testing-packages-locally","title":"Testing Packages locally","text":"<p>This section explains how you can run local versions of the CDK CI/CD Wrapper packages that you have made changes to. You would typically do this when testing new features or fixes that you are trying to contribute to this project.</p>"},{"location":"contributing/index.html#prerequisite","title":"Prerequisite","text":"<ul> <li>An AWS account available for testing with Administrator access.</li> <li>Mac OS / Cloud9 with Ubuntu Server 22.04 LTS Platform</li> <li>Bash/ZSH terminal</li> <li>Task installed using the installation guide</li> <li>Maven installed depending on your OS:<ul> <li>Linux</li> <li>macOs via Homebrew</li> </ul> </li> <li>aws-cli v2 here</li> <li>AWS credentials and profiles for each environment under ~/.aws/config here</li> </ul>"},{"location":"contributing/index.html#first-steps","title":"First steps","text":"<p>Configure the following environment variables.</p> Name Description Required Default Example CreateIfNotExisting AWS_PROFILE AWS Profile to use for interacting with the AWS account. This profile is used to create an AWS CodeArtifact to host the CDK CI/CD Wrapper packages, while the version is not publicly available. true 123456789012 false DOMAIN AWS CodeArtifact Domain name to use true cdk-cicd-wrapper true REPOSITORY AWS CodeArtifact repository name to use true cdk-cicd-wrapper true SECRET_ID AWS SecretManager Secret name to publish to login token. This token will be used by the CDK CI/CD Wrapper pipeline to be able to pull the packages at the Synth stage. true cdk-cicd-wrapper true <p>The values can be placed into a <code>.env</code> file in the root of the project as well, e.g:</p> <pre><code>AWS_PROFILE=my-aws-profile\nDOMAIN=cdk-cicd-wrapper\nREPOSITORY=cdk-cicd-wrapper\nSECRET_ID=codeartifact-secret-id\n</code></pre>"},{"location":"contributing/index.html#checkout-and-initialize-the-code-repository","title":"Checkout and initialize the code repository","text":"<p>You can clone the repository from GitHub.</p> <p>Execute the <code>task init</code> command.</p>"},{"location":"contributing/index.html#publish-the-cdk-cicd-packages-into-aws-codeartifact","title":"Publish the CDK CI/CD packages into AWS CodeArtifact","text":""},{"location":"contributing/index.html#login-to-codeartifact","title":"Login to CodeArtifact","text":"<p>It is highly recommended to set up a separate AWS CodeArtifact for testing and developing the CDK CI/CD Wrapper. With a single <code>task codeartifact:login</code> command you can login to the AWS CodeArtifact. In case the AWS CodeArtifact Domain or Repository are not existing, then it creates it based on the provided DOMAIN, REPOSITORY.</p> <p>The created AWS CodeArtifact Domain and Repository can be deleted with the <code>task codeartifact:repository:delete</code> command.</p> <p>Note The command might fail with message like <code>exit status 255</code> or similar. This means your AWS Session has expired.</p>"},{"location":"contributing/index.html#publish","title":"Publish","text":"<p>The CDK CI/CD Wrapper packages can be publish with the <code>task codeartifact:publish</code> command.</p> <p>This command unpublish the previous package in cases where the package version has not been changed.</p>"},{"location":"contributing/index.html#use-the-packages-from-aws-codeartifact","title":"Use the packages from AWS CodeArtifact","text":"<p>The CDK CI/CD Wrapper packages can be added to any CDK project from the AWS CodeArtifact with the <code>npm install --save @cdklabs/cdk-cicd-wrapper @cdklabs/cdk-cicd-wrapper-cli</code>. Then you can follow the Getting Started Guide.</p>"},{"location":"contributing/index.html#use-a-sample-app-for-development","title":"Use a sample app for development","text":"<p>The repository comes with a <code>samples</code> folder that host example projects to understand the benefit of the CDK CI/CD Wrapper.</p> <p>The available samples can be listed, with the <code>task samples:list</code> command. Set the <code>SAMPLE_APP</code> environment variable name as the folder is called inside the sample folder. Once you've selected a sample, that you'd like to use as baseline you need to then go ahead and initialize a project based on that running the following commands:</p> <pre><code>export SAMPLE_APP=cdk-ts-example;\ntask samples:dev:init\n</code></pre> <p>The last command creates the <code>development/project</code> temporarily folder and initialize the project with Projen.</p>"},{"location":"contributing/index.html#configure-environment-variables-for-the-sample-application","title":"Configure environment variables for the sample application","text":"<p>The environment variables listed on the Variables page. These variables can be included into the <code>.env</code> file in either the root or in the <code>development/project</code> folder.</p> <p>The requirements for the samples projects can be different, so check the README.md file of the sample application for more details.</p> <p>You can verify the detected configuration with the <code>task samples:dev:info</code>. This is recommended if you are managing multiple AWS accounts.</p>"},{"location":"contributing/index.html#bootstrap-the-accounts","title":"Bootstrap the accounts","text":"<p>The accounts must be bootstrapped prior to the first deployment. You can execute it with the <code>task samples:dev:bootstrap</code>.</p>"},{"location":"contributing/index.html#update-the-cdk-cicd-wrapper-libraries-in-the-development","title":"Update the cdk-cicd-wrapper libraries in the development","text":"<p>You can update the packages with the <code>task samples:dev:update</code> command that ensures the latest CDK CI/CD Wrapper is used.</p>"},{"location":"contributing/index.html#deploy-the-pipeline-to-the-account","title":"Deploy the pipeline to the account","text":"<p>You can deploy the pipelines from the development folder with the <code>task samples:dev:deploy</code> command.</p>"},{"location":"contributing/index.html#push-the-sources-of-the-sample-application-up-to-the-generated-repository-aws-codecommit","title":"Push the sources of the sample application up to the generated repository AWS CodeCommit","text":"<p>You can push the changes made into the sample from the folder with the <code>task samples:dev:git:push</code></p>"},{"location":"contributing/index.html#deploy-workbench-stacks","title":"Deploy workbench stacks","text":"<p>The workbench stacks can be deployed with the <code>task samples:dev:workbench:deploy</code>.</p>"},{"location":"contributing/index.html#do-development-iteration","title":"Do development iteration","text":"<p>You can test your changes in the CDK CI/CD Wrapper simply with calling the <code>task samples:dev:loop</code>.</p>"},{"location":"contributing/index.html#faq","title":"FAQ","text":""},{"location":"developer_guides/index.html","title":"Developer Guide","text":"<p>This section provides a conceptual overview and practical examples to help you understand the features provided by the CDK CI/CD Wrapper and how to use them in detail.</p>"},{"location":"developer_guides/audit.html","title":"Audit project dependencies","text":"<p>From the package.json you get the following commands which you can run via the cli like this:</p> <pre><code>npm run audit ### check below the list of sub-scripts\n</code></pre> <pre><code>{\n    ...\n    \"scripts\":\n    {\n        ...\n        \"audit\": \"npx concurrently 'npm:audit:*(!fix)'\",\n        \"audit:deps:nodejs\": \"npx @cdklabs/cdk-cicd-wrapper-cli check-dependencies --npm\",\n        \"audit:deps:python\": \"npx @cdklabs/cdk-cicd-wrapper-cli check-dependencies --python\",\n        \"audit:scan:security\": \"npx @cdklabs/cdk-cicd-wrapper-cli security-scan --bandit --semgrep --shellcheck --ci\",\n        \"audit:license\": \"npm run license\",\n        \"audit:fix:license\": \"npm run license:fix\",\n        \"license\": \"npx @cdklabs/cdk-cicd-wrapper-cli license\",\n        \"license:fix\": \"npx @cdklabs/cdk-cicd-wrapper-cli license --fix\",\n        ...\n    },\n    ...\n}\n</code></pre>"},{"location":"developer_guides/cd.html","title":"Continuous Deployment","text":"<p>CD (Continuous Deployment) is a continuous method of software delivery, where you continuously deploy iterative code changes through out various stages.</p> <p>This iterative process helps reduce the chance that you develop new code based on buggy or failed previous versions. The CDK CI/CD Wrapper can catch bugs early in the development cycle, and help ensure that all the code deployed to production complies with your established code standards.</p>"},{"location":"developer_guides/cd.html#common-terms","title":"Common terms","text":""},{"location":"developer_guides/cd.html#stage","title":"Stage","text":"<p>Stage is a representation of a deployment environment where the solution is deployed. The CDK CI/CD Wrapper requires the RES stage to be defined, because that is the stage where all the CI/CD infrastructure elements will be placed. We recommend to use the DEV, INT, and PROD stages, in this order, but you can define your own Stages.</p>"},{"location":"developer_guides/cd.html#stack","title":"Stack","text":"<p>The unit of deployment in the AWS CDK is called a stack. See more details in the CDK documentation.</p>"},{"location":"developer_guides/cd.html#how-to-define-stacks-to-deploy-on-a-stage","title":"How to define Stacks to deploy on a Stage?","text":"<p>Stacks can be added to all of the stages or can be added only to specific stages. Any correct CDK Stacks can be added to a stage and can be deployed with the CDK CI/CD Wrapper.</p>"},{"location":"developer_guides/cd.html#add-stacks-to-all-stages","title":"Add stacks to all stages","text":"<p>Open your <code>bin/&lt;your-main-file&gt;.ts</code> file and include a stack into the Delivery Pipeline. Here we are using two of our example stacks.</p> <pre><code>PipelineBlueprint.builder().addStack({\n  provide: (context) =&gt; {\n    new example.LambdaStack(context.scope, `${context.blueprintProps.applicationName}LambdaStack`, {\n        applicationName: context.blueprintProps.applicationName,\n        stageName: context.stage,\n    });\n    new example.S3BucketStack(context.scope, `${context.blueprintProps.applicationName}S3Stack`, {\n        bucketName: 'test-bucket',\n        stageName: context.stage,\n        applicationQualifier: context.blueprintProps.applicationQualifier,\n        encryptionKey: context.get(GlobalResources.ENCRYPTION)!.kmsKey,\n    });\n}}).synth(app);\n</code></pre> <p>You can add stacks one by one as well.</p> <pre><code>PipelineBlueprint.builder().addStack({\n  provide: (context) =&gt; {\n    new example.LambdaStack(context.scope, `${context.blueprintProps.applicationName}LambdaStack`, {\n        applicationName: context.blueprintProps.applicationName,\n        stageName: context.stage,\n    });\n}}).addStack({\n  provide: (context) =&gt; {\n    new example.S3BucketStack(context.scope, `${context.blueprintProps.applicationName}S3Stack`, {\n        bucketName: 'test-bucket',\n        stageName: context.stage,\n        applicationQualifier: context.blueprintProps.applicationQualifier,\n        encryptionKey: context.get(GlobalResources.ENCRYPTION)!.kmsKey,\n    });\n}}).synth(app);\n</code></pre>"},{"location":"developer_guides/cd.html#highlights","title":"Highlights","text":"<ol> <li>Your stack's scope must be the one that comes from the <code>context</code> -&gt; <code>context.scope</code> or any other stack you defined in the same addStack block.</li> <li>It is recommended to use the prefixing with on the resources you are creating in your Stack otherwise your resource name can be conflicting. As best practice we use the stageName and the applicationQualifier both as that allows us to deploy multi stage CI/CD pipelines on a single AWS account.</li> <li>You can access GlobalResources through the context <code>context.get(GlobalResources.ENCRYPTION)!.kmsKey</code>, you can read about the GlobalResources</li> <li>You can access the parameters of the blueprint <code>context.blueprintProps</code></li> </ol>"},{"location":"developer_guides/cd.html#add-stack-to-a-specific-stage","title":"Add stack to a specific stage","text":"<pre><code>PipelineBlueprint.builder().addStack({\n  provide: (context) =&gt; {\n    new example.LambdaStack(context.scope, `${context.blueprintProps.applicationName}LambdaStack`, {\n        applicationName: context.blueprintProps.applicationName,\n        stageName: context.stage,\n    });\n}}, vp.COMMON_STAGES.DEV).addStack({\n  provide: (context) =&gt; {\n    new example.S3BucketStack(context.scope, `${context.blueprintProps.applicationName}S3Stack`, {\n        bucketName: 'test-bucket',\n        stageName: context.stage,\n        applicationQualifier: context.blueprintProps.applicationQualifier,\n        encryptionKey: context.get(GlobalResources.ENCRYPTION)!.kmsKey,\n    });\n}}, vp.COMMON_STAGES.INT, vp.COMMON_STAGES.PROD).synth(app);\n</code></pre> <p>With this configuration the <code>LambdaStack</code> will be deployed in the DEV stage only and not in the INT and PROD stages where as the <code>S3BucketStack</code> will be deployed in the INT and PROD stages.</p> <p>Note The deployed stacks can be different for each Stage, although the recommendation is to have similar identical deployments. This is to ensure faulty operation of the setup can be intercepted as early as possible.</p>"},{"location":"developer_guides/cd.html#how-to-define-custom-stages","title":"How to define custom Stages","text":"<p>You can define custom stages through the VanillaPipelineBuilder, so that you can adjust the CD process to your environment setup.</p> <pre><code>PipelineBlueprint.builder()\n    .defineStages([\n        vp.COMMON_STAGES.RES,\n        { stage: 'EXP', account: '1234567891012', region: 'eu-west-1'},\n        { stage: vp.COMMON_STAGES.DEV, account: '2345678910123', region: 'eu-west-1'},\n        { stage: vp.COMMON_STAGES.INT}\n    ])\n    .addStack({\n  provide: (context) =&gt; {\n        new example.LambdaStack(context.scope, `${context.blueprintProps.applicationName}LambdaStack`, {\n            applicationName: context.blueprintProps.applicationName,\n            stageName: context.stage,\n        });\n    }, 'EXP').addStack({\n  provide: (context) =&gt; {\n        new example.S3BucketStack(context.scope, `${context.blueprintProps.applicationName}S3Stack`, {\n            bucketName: 'test-bucket',\n            stageName: context.stage,\n            applicationQualifier: context.blueprintProps.applicationQualifier,\n            encryptionKey: context.get(GlobalResources.ENCRYPTION)!.kmsKey,\n        });\n    }}, vp.COMMON_STAGES.INT, vp.COMMON_STAGES.PROD).synth(app);\n</code></pre> <p>With this example you can see the options of how the Stages can be defined.</p> <ol> <li>Define only the stage name to be a string or any of the COMMONSTAGES. This means you must* create an environment variable called <code>ACCOUNT*&lt;STAGE_NAME&gt;</code>which needs to provide the AWS account id. The targeted region is determined by the<code>AWS_REGION</code> environment variable.</li> <li>You can define an object with the <code>stage</code> property. This means you must create an environment variable called <code>ACCOUNT_&lt;STAGE_NAME&gt;</code> which needs to provide the AWS account id. The targeted region is determined by the <code>AWS_REGION</code> environment variable.</li> <li>You can directly input the <code>account</code> and <code>region</code> in case you want to be explicit.</li> </ol> <p>The order of the stage execution will follow the definition order except for the <code>RES</code> stage because that is always deployed first.</p> <p>Note If the <code>ACCOUNT_&lt;STAGE_NAME&gt;</code> environment variable or the <code>account</code> value is only a <code>-</code>, then that stage is considered disabled.</p> <p>Note The CDK CI/CD Wrapper - CLI Configuration command only asks for the the RES, DEV and INT stages' account information, this means if you add a new stage, it is your responsibility to either define your <code>ACCOUNT_&lt;STAGE_NAME&gt;</code> environment variable and add it to the <code>exports_vars.sh</code> or explicitly add the account numbers in the command.</p>"},{"location":"developer_guides/cdk_context.html","title":"Add/remove cdk.context.json to git remote","text":"<p>When you use a construct's <code>.fromLookup()</code> method, the result of the call is cached in cdk.context.json. You should commit this to the version control along with the rest of your code to make sure that future executions of your CDK app (in the pipeline) use the same value. The CDK Toolkit includes commands to manage the context cache, so you can refresh specific entries when need be. For more information, see Runtime context. In case you decide to put the cdk.context.json into .gitignore to avoid committing your test account ids then you need to:</p> <pre><code>### 1. Remove cdk.context.json from .gitignore\nvi .gitignore ### remove cdk.context.json\n### 2. Generate the cdk.context.json\nsource .env ### source the env vars with the right account ids and profiles for RES/DEV/INT/PROD...\nnpx dotenv-cli -- npm run cdk synth ### this command generates the cdk.context.json\n### 3. Add the cdk.context.json to git remote\ngit add cdk.context.json ### re-add cdk.context.json\ngit commit -am \"feat: re-added cdk.context.json\"\ngit push -u origin ### Push changes to remote\n</code></pre>"},{"location":"developer_guides/ci.html","title":"Continuous Integration","text":"<p>CI (Continuous Integration) is a continuous method of software development, where you continuously build and test iterative code changes.</p> <p>This iterative process helps reduce the chance that you develop new code based on buggy or failed previous versions. The CDK CI/CD Wrapper can catch bugs early in the development cycle, and help ensure that all the code deployed to production complies with your established code standards.</p> <p>The CI functionality of the CDK CI/CD Wrapper can be utilized in any software development process, it is not bound to infrastructure development or AWS CDK projects.</p>"},{"location":"developer_guides/ci.html#common-terms","title":"Common terms","text":""},{"location":"developer_guides/ci.html#phasecommand","title":"PhaseCommand","text":"<p>PhaseCommand represent a single step that is executed by the CI/CD pipeline.</p> <p>These are the available PhaseCommands types:</p> <ul> <li>NPMPhaseCommand - defines an NPM script execution</li> <li>ShellScriptPhaseCommand - defines a shell script execution</li> <li>ShellCommandPhaseCommand - defines a shell command for execution</li> <li>PythonPhaseCommand - defines a python script execution</li> <li>InlineShellPhaseCommand - internal move the given script file content to the build as is. This PhaseCommand is useful in situations where the CDK CI/CD Wrapper sources are not available, for example before network access or NPM registry setups.</li> </ul>"},{"location":"developer_guides/ci.html#phases","title":"Phases","text":"<p>The CDK CI/CD Wrapper has 7 phases which covers every CI/CD project lifecycle. Some of the stages like <code>preDeploy</code> and <code>postDeploy</code> are executed multiple times, while others are only executed once. When a phase is executed it needs to execute all the PhaseCommands defined for the phase in order until completion otherwise the step fails.</p> <p>The following phases are available:</p> <ul> <li>initialize - initializes CI environment before the actual build process can be started. In this phase the networking and the NPM registry connection is established.</li> <li>preBuild - verifies the project is ready for the build</li> <li>build - builds the source code</li> <li>testing - runs testing activities to verify the quality of the product</li> <li>preDeploy - CD phase - prepares and verifies the environment for the deploy</li> <li>deploy - CD phase - deploys the CDK stacks to the stage. This phase can not be modified</li> <li>postDeploy - CD phase - verifies the environment after the deployment and finalize the environment setup</li> </ul>"},{"location":"developer_guides/ci.html#what-are-the-default-set-of-phasecommands-for-the-cdk-cicd-wrapper","title":"What are the default set of PhaseCommands for the CDK CI/CD Wrapper?","text":"<p>The CDK CI/CD Wrapper comes with a pre-set list of PhaseCommand definitions for each stage that provides a good starting point for any AWS CDK projects.</p>"},{"location":"developer_guides/ci.html#initialize-phase","title":"Initialize Phase","text":"Type PhaseCommand Description InlineShellPhaseCommand CONFIGURE_HTTP_PROXY This step configures the HTTP proxy in case it is needed for accessing external resources. You can read more about this in the networking guide. InlineShellPhaseCommand ENVIRONMENT_PREPARATION Populates the environment variables from ParameterStore. InlineShellPhaseCommand NPM_LOGIN Configures the private NPM registry in case it is needed."},{"location":"developer_guides/ci.html#prebuild-phase","title":"PreBuild Phase","text":"Type PhaseCommand Description NPMPhaseCommand VALIDATE Executes the <code>npm run validate</code> command. You can define the command by yourself or you can use CDK CI/CD Wrapper - CLI Validate command NPMPhaseCommand CHECK_AUDIT Executes the <code>npm run audit</code> command. You can define the command by yourself or you can our recommended audit definition. NPMPhaseCommand NPM_CI Runs the <code>npm ci</code> command and downloads all dependencies NPMPhaseCommand CHECK_LINT Executes the <code>npm run audit</code> command. You can define the command by yourself"},{"location":"developer_guides/ci.html#build-phase","title":"Build Phase","text":"Type PhaseCommand Description NPMPhaseCommand BUILD Executes the <code>npm run build</code> command."},{"location":"developer_guides/ci.html#testing-phase","title":"Testing Phase","text":"Type PhaseCommand Description NPMPhaseCommand TEST Executes the <code>npm run test</code> command. InlineShellPhaseCommand CDK_SYNTH_WITH_LOOK_UP Executes the <code>cdk synth</code> command to synthesize the CDK project code and runs the CDK NAG. This version allows the CDK to perform lookups."},{"location":"developer_guides/ci.html#what-are-the-available-phasecommands","title":"What are the available PhaseCommands?","text":"Type PhaseCommand Description InlineShellPhaseCommand CONFIGURE_HTTP_PROXY This step configures the HTTP proxy in case it is needed for accessing external resources. You can read more about this in the networking guide. InlineShellPhaseCommand ENVIRONMENT_PREPARATION Populates the environment variables from ParameterStore. InlineShellPhaseCommand NPM_LOGIN Configures the private NPM registry in case it is needed. NPMPhaseCommand VALIDATE Executes the <code>npm run validate</code> command. You can define the command by yourself or you can use CDK CI/CD Wrapper - CLI Validate command NPMPhaseCommand CHECK_AUDIT Executes the <code>npm run audit</code> command. You can define the command by yourself or you can our recommended audit definition. NPMPhaseCommand NPM_CI Runs the <code>npm ci</code> command and downloads all dependencies NPMPhaseCommand CHECK_LINT Executes the <code>npm run audit</code> command. You can define the command by yourself NPMPhaseCommand BUILD Executes the <code>npm run build</code> command. NPMPhaseCommand TEST Executes the <code>npm run test</code> command. InlineShellPhaseCommand CDK_SYNTH_WITH_LOOK_UP Executes the <code>cdk synth</code> command to synthesize the CDK project code and runs the CDK NAG. This version allows the CDK to perform lookups. InlineShellPhaseCommand CDK_SYNTH_WITHOUT_LOOK_UP Executes the <code>cdk synth</code> command to synthesize the CDK project code and runs the CDK NAG. This version does not allow the CDK to perform lookups."},{"location":"developer_guides/ci.html#how-to-define-a-new-phasecommand","title":"How to define a new PhaseCommand?","text":"<p>There are cases when a new command needs to be added to the CI/CD pipeline. As a first step you need to determine the type of the command. See the list of available PhaseCommand types, if none of those types seems to fit, you always have an option to define your own type.</p> <p>Let's see the two most common cases you could encounter.</p>"},{"location":"developer_guides/ci.html#define-npm-script-based-phasecommand","title":"Define NPM script based PhaseCommand","text":"<p>First ensure the <code>script</code> is defined in your package.json file and the scripts execution result the expected outcome. So your package.json might look like this:</p> <pre><code>{\n    ...\n    \"scripts\":\n    {\n        ...\n        \"my-script\": \"ls\"\n        ...\n    },\n    ...\n}\n</code></pre> <p>Then you can create an NPMPhaseCommand with:</p> <pre><code>const myScriptPhaseCommand = new NPMPhaseCommand('my-script');\n</code></pre> <p>Now the command is ready, we need to include it into our desired phase. Once a default phase has been modified we require you to explicitly define the PhaseCommands for that phase.</p> <p>The phase can be defined with the <code>definePhase</code> method that is available on the VanillaPipelineBuilder.</p> <pre><code>const myScriptPhaseCommand = new NPMPhaseCommand('my-script');\n\nPipelineBlueprint.builder()\n  .addStack((context) =&gt; {\n    new DemoStack(context.scope, 'DemoStack');\n  })\n  .definePhase(PipelinePhases.PRE_BUILD, [\n    PhaseCommands.VALIDATE,\n    myScriptPhaseCommand,\n    PhaseCommands.CHECK_AUDIT,\n    PhaseCommands.NPM_CI,\n    PhaseCommands.CHECK_LINT\n  ])\n  .synth(app);\n</code></pre> <p>Here, you can see how to define the order of the commands, for the phase.</p>"},{"location":"developer_guides/ci.html#define-shell-command-based-phasecommand","title":"Define Shell command based PhaseCommand","text":"<p>You can create a ShellCommandPhaseCommand with:</p> <pre><code>const myScriptPhaseCommand = new sh('ls');\n</code></pre> <p>Now, the command is ready, we need to include into our desired phase. Once a default phase has been modified we require you to explicitly define the PhaseCommands for that phase.</p> <p>The phase can be defined with the <code>definePhase</code> method that is available on the VanillaPipelineBuilder.</p> <pre><code>PipelineBlueprint.builder()\n  .addStack((context) =&gt; {\n    new DemoStack(context.scope, 'DemoStack');\n  })\n  .definePhase(PipelinePhases.PRE_BUILD, [\n    PhaseCommands.VALIDATE,\n    sh('ls'),\n    PhaseCommands.CHECK_AUDIT,\n    PhaseCommands.NPM_CI,\n    PhaseCommands.CHECK_LINT\n  ])\n  .synth(app);\n</code></pre>"},{"location":"developer_guides/ci.html#how-to-define-a-new-phasecommand-type","title":"How to define a new PhaseCommand Type?","text":"<p>Every PhaseCommand must implement the PhaseCommand interface that has only one required command property. This command property must contain an executable command that the <code>sh</code> shell engine can execute, as this command will be added to the underlining AWS CodeBuild project <code>buildSpec.yaml</code> as part of the commands list.</p>"},{"location":"developer_guides/ci.html#how-to-define-the-order-of-the-phasecommands","title":"How to define the order of the PhaseCommands?","text":"<p>The execution order of the PhaseCommands follows the PhaseCommand position in the definition array.</p> <pre><code>const myScriptPhaseCommand = new NPMPhaseCommand('my-script');\n\nPipelineBlueprint.builder()\n  .addStack((context) =&gt; {\n    new DemoStack(context.scope, 'DemoStack');\n  })\n  .definePhase(PipelinePhases.PRE_BUILD, [\n    PhaseCommands.VALIDATE,\n    myScriptPhaseCommand,\n    PhaseCommands.CHECK_AUDIT,\n    PhaseCommands.NPM_CI,\n    PhaseCommands.CHECK_LINT\n  ])\n  .synth(app);\n</code></pre> <p>The <code>npm run validation</code> will be executed before the <code>npm run my-script</code> command.</p>"},{"location":"developer_guides/ci.html#using-buildspec-files","title":"Using BuildSpec files","text":"<p>The CDK CI/CD Wrapper allows to use the <code>buildSpec.yaml</code> file to define the build process instead of the PhaseCommands.</p> <p>To use the <code>buildSpec.yaml</code> file you need configure it with the <code>buildSpecFromFile()</code> method of the <code>PipelineBlueprint</code> builder..</p> <pre><code>PipelineBlueprint.builder()\n  .buildSpecFromFile('path/to/buildSpec.yaml')\n  .addStack((context) =&gt; {\n    new DemoStack(context.scope, 'DemoStack');\n  })\n  .synth(app);\n</code></pre> <p>The <code>buildSpec.yaml</code> file should be placed in the root of the project and should contain the build process definition. It has to contain the commands to generate the build artifacts, run the tests and synthesize the CDK stacks.</p> <pre><code>version: 0.2\n\nphases:\n  install:\n    runtime-versions:\n      nodejs: 20\n    commands:\n      - npm ci\n  build:\n    commands:\n      - npm run build\n  post_build:\n    commands:\n      - npm run test\n      - cdk synth\n</code></pre> <p>Note: The changes in the <code>buildSpec.yaml</code> will be applied after the next pipeline self-mutation.</p>"},{"location":"developer_guides/ci.html#inline-buildspec-definition","title":"Inline BuildSpec definition","text":"<p>The <code>buildSpec.yaml</code> file can be defined inline as well.</p> <pre><code>PipelineBlueprint.builder()\n  .buildSpec(cdk.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      install: {\n        runtime-versions: {\n          nodejs: 20\n        },\n        commands: [\n          'npm ci'\n        ]\n      },\n      build: {\n        commands: [\n          'npm run build'\n        ]\n      },\n      post_build: {\n        commands: [\n          'npm run test',\n          'cdk synth'\n        ]\n      }\n    }\n  }))\n  .addStack((context) =&gt; {\n    new DemoStack(context.scope, 'DemoStack');\n  })\n  .synth(app);\n</code></pre>"},{"location":"developer_guides/global_resource.html","title":"Global Resources","text":"<p>CDK CI/CD Wrapper uses a simple Dependency Injection system to ease the complexity of the cross-cutting resource generation. On this page you can read more about how it is been used in the CDK CI/CD Wrapper and how can you use for your benefit as well.</p>"},{"location":"developer_guides/global_resource.html#dependency-injection-and-resource-providers","title":"Dependency Injection and Resource Providers","text":"<p>The benefit of the dependency injection is that the stack dependency implementations are decoupled from the stack and the CDK CI/CD Wrapper manages the creation of those resources.</p> <p>Let's see an example:</p> <pre><code>new vp.S3BucketStack(context.scope, `${context.blueprintProps.applicationName}S3Stack`, {\n    bucketName: 'test-bucket',\n    stageName: context.stage,\n    applicationQualifier: context.blueprintProps.applicationQualifier,\n    encryptionKey: context.get(GlobalResources.Encryption)!.kmsKey,\n}\n</code></pre> <p>You can see here the S3BucketStack requires a KMS key to perform server-side encryption. Here, we can leverage one of our built-in providers that allows you to access a KMS Key that is dedicated to your pipeline for the particular stage in which your stack is deployed. You don't need to manage the key creation, it is managed for you and will be available whenever you need it.</p> <p>All the Resource Providers accessible through the <code>resourceContext</code> parameter.</p>"},{"location":"developer_guides/global_resource.html#existing-resource-providers","title":"Existing Resource Providers","text":""},{"location":"developer_guides/global_resource.html#compliance-bucket-resource-provider","title":"Compliance Bucket Resource Provider","text":""},{"location":"developer_guides/global_resource.html#parameterstore","title":"ParameterStore","text":""},{"location":"developer_guides/global_resource.html#how-to-define-you-resource-provider","title":"How to define you Resource Provider","text":""},{"location":"developer_guides/modularizing_stacks.html","title":"Modularizing Stacks with BaseStackProvider","text":"<p>In complex CDK projects, managing inlined stacks within <code>PipelineBlueprint.builder()</code> can become cumbersome. To enhance organization and reusability, the <code>BaseStackProvider</code> abstraction offers a powerful solution.</p>"},{"location":"developer_guides/modularizing_stacks.html#creating-a-custom-stack-provider","title":"Creating a Custom Stack Provider","text":"<p>The <code>BaseStackProvider</code> serves as an abstract base class that you can extend to define your stack provisioning logic. The core implementation lies within the mandatory <code>stacks()</code> function.</p> <pre><code>import { Stage, BaseStackProvider } from '@cdklabs/cdk-cicd-wrapper';\nimport * as cdk from 'aws-cdk-lib';\n\nexport class ExampleProvider extends BaseStackProvider {\n\n  stacks(): void {\n    // Define your stack configuration here\n    new cdk.Stack(this.scope, 'ExampleStack', {\n      env: this.env,\n      // ... other stack properties\n    });\n  }\n}\n</code></pre>"},{"location":"developer_guides/modularizing_stacks.html#leveraging-the-custom-provider","title":"Leveraging the Custom Provider","text":"<p>Once you've created your custom provider, integrate it seamlessly within your pipeline blueprint:</p> <pre><code>import { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\nimport { ExampleProvider } from './example-provider'; // Assuming your provider is in a separate file\n\nconst pipeline = PipelineBlueprint.builder()\n  .addStack(new ExampleProvider())\n  .synth(app);\n</code></pre>"},{"location":"developer_guides/modularizing_stacks.html#best-practices","title":"Best Practices","text":"<ul> <li>Modular Organization: For optimal maintainability, create separate providers for distinct logical units within your application. This promotes code clarity and simplifies future modifications.</li> <li>Extensibility with Hooks: The BaseStackProvider provides optional preHooks and postHooks methods that you can override to execute custom logic before and after stack creation, respectively. This empowers you to inject additional processing steps into your pipeline as needed.</li> <li>Secure Key Management: Utilize a dedicated AWS Key Management Service (KMS) key for encryption purposes. This key can be retrieved using the this.encryptionKey property within your custom provider class.</li> <li>Centralized Configuration Management: Access and leverage SSM Parameters to store and retrieve configuration values securely. You can utilize the resolve(ssmParameterName: string) function provided by the BaseStackProvider to retrieve these parameters within your stacks</li> </ul> <p>By adhering to these guidelines, you'll establish a well-structured, scalable approach to managing CDK stacks within your development workflows.</p>"},{"location":"developer_guides/networking.html","title":"Networking","text":""},{"location":"developer_guides/networking.html#determine-vpc-and-proxy-settings-for-your-pipeline","title":"Determine VPC and Proxy settings for your pipeline","text":"<p>By default, the Pipeline is configured to run without a VPC. To have it run inside a VPC, there are two options: <code>VPC</code> and <code>VPC_FROM_LOOK_UP</code>. These options are configured using <code>npx @cdklabs/cdk-cicd-wrapper-cli configure</code> described in the next section.</p> <p>Use <code>VPC</code> if you want a single, self-contained pipeline running in a VPC. This is not recommended for use with multiple code pipelines in the same account. The VPC is created using defaulted settings.</p> <p>Use <code>VPC_FROM_LOOK_UP</code> to look up an existing VPC based on its vpc ID. It is recommended to create this VPC prior to deploying the pipeline. Multiple deployments of the pipeline can share the same VPC.</p> <p>Note: Switching between VPC options may require a complete tear down and redeploy of the pipeline</p> <p>Proxy Configuration requires proxy information to be stored in Secrets manager. Make note of the secret arn is needed in the next step.</p>"},{"location":"developer_guides/pipeline_options.html","title":"Advanced Pipeline Configuration Options","text":"<p>These new options allow you to configure the AWS CDK CodePipeline values.</p> <p>In this guide, we'll explore new properties for configuring your CI/CD pipeline using the CDK CI/CD Wrapper, along with their benefits, use cases, and code examples.</p>"},{"location":"developer_guides/pipeline_options.html#self-mutation","title":"Self-Mutation","text":"<p>Ideal for projects that require infrequent updates to the pipeline configuration, ensuring the pipeline remains the same.</p> <p>Property: <code>selfMutation</code> - Description: Allows the pipeline to update itself. - Type: <code>boolean</code> - Default: <code>true</code></p> <p>Code Example: <pre><code>import { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst pipeline = PipelineBlueprint.builder()\n   .pipelineOptions({\n       selfMutation: false,\n    }).synth(app);\n</code></pre></p>"},{"location":"developer_guides/pipeline_options.html#publish-assets-in-parallel","title":"Publish Assets in Parallel","text":"<p>Beneficial for large projects with multiple assets, where improving concurrency and reducing publishing latency can significantly speed up the CI/CD process, but may also increase overall provisioning time of the CodeBuild projects.</p> <p>Property: <code>publishAssetsInParallel</code> - Description: Publishes assets using multiple CodeBuild projects. - Type: <code>boolean</code> - Default: true</p> <p>Code Example: <pre><code>import { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst pipeline = PipelineBlueprint.builder()\n   .pipelineOptions({\n       publishAssetsInParallel: false,\n    }).synth(app);\n</code></pre></p>"},{"location":"developer_guides/pipeline_options.html#docker-credentials","title":"Docker Credentials","text":"<p>Necessary for projects that involve building, synthesizing, updating, or publishing Docker images, ensuring secure and efficient access to Docker registries.</p> <p>Property: <code>dockerCredentials</code> - Description: List of credentials for authenticating to Docker registries. - Type: <code>pipelines.DockerCredential[]</code> - Default: <code>[]</code></p> <p>Code Example: <pre><code>import { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\nimport { DockerCredential } from 'aws-cdk-lib/pipelines';\n\nconst dockerCreds: DockerCredential[] = [\n    DockerCredential.ecr('arn:aws:iam::123456789012:role/MyECRRole'),\n];\n\nconst pipeline = PipelineBlueprint.builder()\n   .pipelineOptions({\n       dockerCredentials: dockerCreds,\n    }).synth(app);\n</code></pre></p>"},{"location":"developer_guides/pipeline_options.html#use-change-sets","title":"Use Change Sets","text":"<p>Recommended for projects that require thorough review before deployment, as it allows for safe execution and rollback if needed. However, this option may increase deployment time due to the additional change set creation and execution steps.</p> <p>Property: <code>useChangeSets</code> - Description: Deploys stacks by creating and executing change sets. - Type: <code>boolean</code> - Default: <code>true</code></p> <p>Code Example: <pre><code>import { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst pipeline = PipelineBlueprint.builder()\n   .pipelineOptions({\n       useChangeSets: false,\n    }).synth(app);\n</code></pre></p>"},{"location":"developer_guides/private_npm_registry.html","title":"Using private NPM registry","text":"<p>A private npm registry is a custom repository for hosting Node.js packages, which are not available to the general public. The private NPM registry has to be configured in both local and on the CI/CD environment.</p>"},{"location":"developer_guides/private_npm_registry.html#local-setup","title":"Local setup","text":"<p>Configuring a private npm registry using the .npmrc file involves specifying the registry URL and authentication credentials. Here's a step-by-step guide:</p> <ol> <li> <p>Obtain Authorization Token:    To access private packages from a registry, you need an authorization token. This token grants you permission to download and publish packages to the private registry. You can generate a token from your private registry's administrative dashboard or using the registry's authentication mechanism.</p> </li> <li> <p>Create a .npmrc File:    Create a file named <code>.npmrc</code> in the root directory of your project. This file will store your registry URL and authentication credentials.</p> </li> <li> <p>Specify Registry URL:</p> </li> </ol> <p>In the .npmrc file, add the URL of your private registry. For instance, if your registry URL is https://private-registry.example.com, add the following line:</p> <pre><code>registry=https://private-registry.example.com\n</code></pre> <p>3.1 Specify scope In case you want to use the registry only for scoped dependencies, add the scope definition before the registry.</p> <pre><code>@cdklabs:registry=https://private-registry.example.com\n</code></pre> <ol> <li>Add Authentication Credentials:</li> </ol> <p>To authenticate with the private registry, you need to specify your authorization token. There are two ways to do this:</p> <p>Basic Authentication:</p> <p>Add the following lines to your `.npmrc`` file:</p> <pre><code>//private-registry.example.com/:_authToken=your-token\n</code></pre> <p>API Token:</p> <p>If your registry supports API tokens, you can use the <code>//registry.npmjs.org/:_authToken=${NPM_TOKEN}</code> format. Set the <code>NPM_TOKEN</code> environment variable to your API token value.</p>"},{"location":"developer_guides/private_npm_registry.html#example","title":"Example:","text":"<pre><code># Content of .npmrc\n@cdklabs:registry=https://jfrog.com/artifactory/api/npm/cdklabs-npm-release/\n//jfrog.com/artifactory/api/npm/cdklabs-npm-release/:_authToken=eya......\n</code></pre> <p>Anytime you modify the <code>.npmrc</code> file it is highly recommended to verify the new configuration. It can be done with an <code>npm ci</code> call.</p> <p>Note Never share your authentication tokens or commit the .npmrc file.</p> <p>Note .npmrc file must be placed into the project root folder as it is used by the various audit processes as well to interact with the repository</p>"},{"location":"developer_guides/private_npm_registry.html#cicd-environment-setup","title":"CI/CD environment setup","text":"<p>The private npm registry information must to be configured for the CI CD pipeline as well.</p> <p>The <code>CDK CI/CD WrapperBuilder</code> has a configuration method which accepts:</p> <ul> <li>url: NPM registry url</li> <li>basicAuthSecretArn: AWS SecretManager Secret arn, will be detailed soon</li> <li>scope: NPM Registry scope if it is used</li> </ul> <p>To set this configuration you must add the following to your code where you have defined CDK CI/CD WrapperBuilder <pre><code>import * as vp from '@cdklabs/cdk-cicd-wrapper';\n\nconst npmRegistryConfig: vp.NPMRegistryConfig = {\n  url: \"https://&lt;your-domain&gt;-&lt;your-aws-account-id&gt;.d.codeartifact.&lt;region&gt;.amazonaws.com/npm/&lt;your-repository&gt;/\", \n  basicAuthSecretArn: \"&lt;your-secret-arn&gt;\", \n  scope: \"&lt;scope&gt;\" \n};\n\nvp.CDK CI/CD WrapperBlueprint.builder().npmRegistry(npmRegistryConfig).synth(app);\n</code></pre></p> <p>The NPM Authentication Token needs to remain secret that is why the CDK CI/CD Wrapper uses AWS SecretManager to store it.</p> <p>Create a secret in AWS Secrets Manager and store the authentication token as plaintext. This is viable for long living tokens. The value of the secret needs to be only the token. Provide the arn of this secret as <code>basicAuthSecretArn</code> either as a hardcoded string  in your npmRegistryConfig or through an environment variable but in this case the environment variable name must be <code>NPM_BASIC_AUTH_SECRET_ID</code>.</p> <p>Note It is recommended to use technical users and token dedicated to them, rather than personal tokens.</p>"},{"location":"developer_guides/python_dependencies.html","title":"Working with Python dependencies","text":"<p>The project utilizes the Pipenv. Pipenv automatically creates and manages a virtual enviornment for your projects, as well as adds/removes packages from your <code>Pipfile</code> as you install/uninstall packages. It also generates a project <code>Pipfile.lock</code>, which is used to produce deterministic builds.</p> <p>The Python dependencies are maintained in <code>Pipfile</code> instead of the <code>requirements.txt</code> file and requirements.txt files should not be committed into Git.</p>"},{"location":"developer_guides/python_dependencies.html#how-to-install-pipenv","title":"How to install Pipenv","text":"<p>The recommended approach is to use <code>pip install pipenv -U</code> command. More information can be found here.</p> <p>The <code>pipenv</code> command is not added to the $PATH by default that need to be done manually. The <code>pipenv</code> command location can be determined by executing:</p> <pre><code>python3 -m site --user-base\n</code></pre> <p>This will return a value like <code>/Users/user/Library/Python/3.11</code>. Then the $PATH needs to be extended with the <code>/Users/user/Library/Python/3.11/bin</code>.</p> <pre><code>export PATH=\"${PATH}:/Users/user/Library/Python/3.11/bin\";\n</code></pre> <p>You can add this your <code>$HOME/.zshrc</code> or <code>$HOME/.bashrc</code> to have this folder permanently.</p>"},{"location":"developer_guides/python_dependencies.html#migrating-existing-requirementstxt","title":"Migrating existing <code>requirements.txt</code>","text":"<p>Existing <code>requirements.txt</code> can be transformed into a <code>Pipfile</code> with the <code>pipenv install</code> command:</p> <pre><code>cd path-to-the-module\npipenv install -r requirements.txt &amp;&amp; pipenv lock\n</code></pre> <p><code>Pipfile</code> has to be created where the <code>requirements.txt</code> would be created. That folder will be considered as a Python module.</p>"},{"location":"developer_guides/python_dependencies.html#installing-a-new-dependency","title":"Installing a new dependency","text":"<p>The <code>pipenv</code> command install api is identical as the <code>pip</code> commands.</p> <pre><code>pipenv install &lt;dependency&gt;\n</code></pre>"},{"location":"developer_guides/python_dependencies.html#updating-lock-file","title":"Updating lock file","text":"<p>The <code>Pipfile.lock</code> can be updated with the <code>pipenv lock</code> command.</p>"},{"location":"developer_guides/python_dependencies.html#installing-dependencies-based-on-the-pipfilelock","title":"Installing dependencies based on the <code>Pipfile.lock</code>","text":"<p>The locked dependencies can be installed with the locked version with the <code>pipenv sync</code> command.</p>"},{"location":"developer_guides/security.html","title":"Security on CDK CI/CD Wrapper","text":"<p>CDK CI/CD Wrapper brings the IaaC security to a new level with its built-in toolsets based on AWS best practices and industry wide standards. It includes Static Application Security Testing (SAST), Dependency Vulnerability Scanning, and AI based vulnerability scanning.</p>"},{"location":"developer_guides/security.html#reference-sheet-of-security-controls","title":"Reference sheet of Security controls","text":"Security Tool Type Status Limitations Description AWS CDK NAG Static Application Security Testing Enabled cdk-nag integrates directly into AWS Cloud Development Kit (AWS CDK) applications to provide identification and reporting mechanisms similar to SAST tooling. [] Amazon CodeGuru Reviewer Static Application Security Testing Enabled Supported with AWS CodeCommit repository only. Verify Pull Requests only and users can by pass Amazon CodeGuru Reviewer detect vulnerabilities and automate code reviews with machine-learning powered recommendations. Amazon CodeGuru Security Static Application Security Testing Disabled Amazon CodeGuru Security is in preview release and is subject to change. Amazon CodeGuru Security is a static application security testing (SAST) tool that combines machine learning (ML) and automated reasoning to identify vulnerabilities in your code, provide recommendations on how to fix the identified vulnerabilities, and track the status of the vulnerabilities until closure. Better-NPM-Audit Dependency Scanning for Vulnerabilities Enabled Verifies NPM dependencies Scans the dependencies for known vulnerabilities CVEs. pip-audit Dependency Scanning for Vulnerabilities Enabled Verifies Python dependencies based on the provided Pipfiles. Scans the dependencies for known vulnerabilities CVEs. semgrep Static Security Code Scanner Enabled Scans the codebase for vulnerabilities. shellcheck Static Security Code Scanner Enabled Analyses Shell Scripts Scans the codebase for vulnerabilities. Bandit Static Security Code Scanner Enabled Analyses Python source codes Scans the codebase for vulnerabilities."},{"location":"developer_guides/security.html#tools-description","title":"Tools description","text":""},{"location":"developer_guides/security.html#aws-cdk-nag","title":"AWS CDK Nag","text":"<p>cdk-nag integrates directly into AWS Cloud Development Kit (AWS CDK) applications to provide identification and reporting mechanisms similar to SAST tooling.</p> <p>CDK Nag is applied as a CDK Aspect and it looks for patterns in the CDK Application that may indicate insecure infrastructure. Roughly speaking, it will look for:</p> <ul> <li>IAM rules that are too permissive (wildcards)</li> <li>Security group rules that are too permissive (wildcards)</li> <li>Access logs that aren't enabled</li> <li>Encryption that isn't enabled</li> <li>Password literals</li> <li>and many more</li> </ul> <p>The CDK Nag verification is executed to during the <code>cdk synth</code> phase. &lt;&lt;!\u2014did mean \u201calso\u201d with the \u201cto\u201d -&gt;&gt;</p> <p>If you have assessed the risk of new finding and want to suppress these CDK Nag rules to prevent them from failing the CDK Deploymen then you should do so in their own dedicated stacks rather than doing it centrally.</p> <p>More information about the CDK Nag can be found on these locations:</p> <ul> <li>AWS CDK NAG</li> <li>Manage application security and compliance with the AWS Cloud Development Kit and cdk-nag</li> </ul>"},{"location":"developer_guides/security.html#how-to-enable-disable","title":"How to enable / disable","text":"<p>The AWS CDK Nag is such an essential part of ensuring the security of the IaaC project that it\u2019s use is mandatory.</p>"},{"location":"developer_guides/security.html#amazon-codeguru-reviewer","title":"Amazon CodeGuru Reviewer","text":"<p>Amazon CodeGuru Reviewer detects vulnerabilities and automates code reviews with machine-learning powered recommendations.</p> <p>Amazon CodeGuru Reviewer is included in pipelines created with AWS CodeCommit as VCS and it automatically reviews the created Pull Requests and provides actionable recommendations on the changes.</p> <p>Amazon CodeGuru Reviewer recommendations are available directly on the Pull Requests or on the AWS Console / Amazon CodeGuru / Reviewer / Code Reviews.</p>"},{"location":"developer_guides/security.html#how-to-enable-disable_1","title":"How to enable / disable","text":"<p>The scanning can be enabled/disabled with the <code>AppConfig.repositoryConfig.CODECOMMIT.codeGuruReviewer</code> configuration. If the configuration value is true then it is enabled. If the configuration false then it is disabled.</p>"},{"location":"developer_guides/security.html#amazon-codeguru-security","title":"Amazon CodeGuru Security","text":"<p>Amazon CodeGuru Security is a static application security testing (SAST) tool that combines machine learning (ML) and automated reasoning to identify vulnerabilities in your code, providing recommendations on how to fix the identified vulnerabilities, and tracking the status of the vulnerabilities until closure.</p> <p>Amazon Code Guru is applied on the pipeline as part of the Build stage to ensures the solution security meets with the highest standard. The scanning stops the pipeline in case there is any findings that have higher severity than <code>High</code> default. The threshold level can be adjusted by the <code>AppConfig.codeGuruScanThreshold</code> configuration option.</p> <p>The Amazon Code Guru findings and recommendations can be found on the AWS Console / Amazon CodeGuru / Security / Findings . The Findings page provides a holistic view about the security recommendations. Information about each Scan can be found on the AWS Console / Amazon CodeGuru / Security / Scans page.</p>"},{"location":"developer_guides/security.html#how-to-enable-disable_2","title":"How to enable / disable","text":"<p>The scanning can be enabled/disabled with the <code>AppConfig.codeGuruScanThreshold</code> configuration. If the configuration is present than it is enabled. If the configuration is missing the scan will be disabled.</p>"},{"location":"developer_guides/security.html#better-npm-audit","title":"Better NPM Audit","text":"<p>The goal of this project is to provide additional features on top of the existing npm audit options. We hope to encourage more people to do security audits for their projects.</p> <p>More information about Better NPM Audit.</p>"},{"location":"developer_guides/security.html#how-to-disable","title":"How to disable","text":"<p>Remove the <code>audit:deps:nodejs</code> script from the <code>package.json</code>.</p>"},{"location":"developer_guides/security.html#pip-audit","title":"pip-audit","text":"<p>pip-audit is a tool for scanning Python environments for packages with known vulnerabilities. It uses the Python Packaging Advisory Database (https://github.com/pypa/advisory-database) via the PyPI JSON API as a source of vulnerability reports.</p> <p>More information about pip-audit.</p>"},{"location":"developer_guides/security.html#how-to-disable_1","title":"How to disable","text":"<p>Remove the <code>audit:deps:python</code> script from the <code>package.json</code>.</p>"},{"location":"developer_guides/security.html#semgrep","title":"Semgrep","text":"<p>Semgrep accelerates your security journey by swiftly scanning code and package dependencies for known issues, software vulnerabilities, and detected secrets with unparalleled efficiency. Semgrep offers:</p> <ul> <li>Code to find bugs &amp; vulnerabilities using custom or pre-built rules</li> <li>Supply Chain to find dependencies with known vulnerabilities</li> <li>Secrets to find hard-coded credentials that shouldn't be checked into source code</li> </ul> <p>More information about Semgrep.</p>"},{"location":"developer_guides/security.html#how-to-enable-disable_3","title":"How to enable / disable","text":"<p>Add/remove the <code>semgrep</code> entry to/from the <code>SECURITY_SCANNERS</code> list in the <code>scripts/check-code-scan-security.sh</code>.</p>"},{"location":"developer_guides/security.html#shellcheck","title":"Shellcheck","text":"<p>ShellCheck is a static analysis tool for shell scripts.</p> <p>More information about ShellCheck.</p>"},{"location":"developer_guides/security.html#how-to-enable-disable_4","title":"How to enable / disable","text":"<p>Add/remove the <code>shellcheck</code> entry to/from the <code>SECURITY_SCANNERS</code> list in the <code>scripts/check-code-scan-security.sh</code>.</p>"},{"location":"developer_guides/security.html#bandit","title":"Bandit","text":"<p>Bandit is a tool designed to find common security issues in Python code. To do this, Bandit processes each file, builds an AST from it, and runs appropriate plugins against the AST nodes.</p> <p>More information about Bandit.</p>"},{"location":"developer_guides/security.html#how-to-enable-disable_5","title":"How to enable / disable","text":"<p>Add/remove the <code>bandit</code> entry to/from the <code>SECURITY_SCANNERS</code> list in the <code>scripts/check-code-scan-security.sh</code>.</p>"},{"location":"developer_guides/security.html#security-checks-on-github-actions","title":"Security checks on GitHub Actions","text":"<p>GitHub Actions executes the enabled security checks as part of the pull requests checks. In case any of the enabled security tools identify a security issue the corresponding check fails and protect the codebase.</p> <p>For Bandit, Shellcheck, and Semgrep tools the Github Actions integration converts the security findings to Junit and Checkstyle outputs that Github can present in the <code>Files changed</code> tab to help the troubleshooting.</p> <p>If there is no security findings from these tools:</p> <ul> <li>the <code>Checkstyle Source Code Analyzer report</code> will report <code>0 violation(s) found</code> that means the Shellcheck tool has not found any issue</li> <li>the <code>JUnit Test Report</code> will report <code>No test results found!</code> that means neither the Semgrep nor the Bandit tools have not found any issue</li> </ul> <p>Notice: As the actual security scanning is not part of the <code>Checkstyle Source Code Analyzer</code> or <code>JUnit</code> these reports will report 0s as execution time. The scanning of these tools are executed as part of the <code>Security Scans</code></p>"},{"location":"developer_guides/variables.html","title":"Variables","text":""},{"location":"developer_guides/variables.html#cdk-cicd-wrapper-variables","title":"CDK CI/CD Wrapper Variables","text":"ENV Variable Package.json config Default Value Description AWS_REGION deployment region ACCOUNT_RES account id for resources account where pipeline will run ACCOUNT_DEV account id for DEV environment account ACCOUNT_INT account id for INT environment account RES_ACCOUNT_AWS_PROFILE sets the named profile to use for the RES account. this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> DEV_ACCOUNT_AWS_PROFILE sets the named profile to use for the DEV account. this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> INT_ACCOUNT_AWS_PROFILE sets the named profile to use for the INT account. this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> AWS_PROFILE sets the default named profile to use for aws cli or cdk commands when no <code>--profile</code> is provided. set to the same value as <code>RES_ACCOUNT_AWS_PROFILE</code> this profile must exist in <code>~/.aws/credentials</code> or <code>~/.aws/config</code> applicationName Wrapper sets the name of the Application CDK_QUALIFIER cdkQualifier wrapper used to distinguish between multiple deployments of a VP project in the same account. Good practice to customize per deployment. GIT_REPOSITORY repositoryName sets the name of the Git repository in the format org/name REPOSITORY_TYPE repositoryType sets the type of the repository, <code>GITHUB</code> or <code>CODECOMMIT</code> CODESTAR_CONNECTION_ARN sets the codestar connection required for GITHUB type CICD_VPC_TYPE cicdVpcType NO_VPC sets the type of the VPC: <code>NO_VPC</code>, <code>VPC</code>, or <code>VPC_FROM_LOOK_UP</code>. CICD_VPC_ID cicdVpcId for use with <code>VPC_FROM_LOOK_UP</code> to set the vpc ID CICD_VPC_CIDR cicdVpcCidr 172.31.0.0/20 for use with <code>VPC</code> to set the CIDR block of the VPC CICD_VPC_CIDR_MASK cicdVpcCidrMask 24 for use with <code>VPC</code> to set the Subnet size PROXY_SECRET_ARN used to set the ARN for the proxy secrets to enable proxy"},{"location":"developer_guides/vcs_codecommit.html","title":"AWS CodeCommit Integration","text":"<p>To be able to use AWS CodeCommit repositories in AWS CodePipeline with vanilla-pipeline, you can do this directly in the configure step.</p>"},{"location":"developer_guides/vcs_codecommit.html#quick-setup","title":"Quick Setup","text":"<p>After the configure has finished and generated the .env file then you need to add the changes into git and commit them.</p> <p>You need to configure the downstream of the repository for deployment. In your local machine you need to install the <code>git-remote-codecommit</code> using the following command:</p> <pre><code>sudo pip3 install git-remote-codecommit\n</code></pre> <pre><code>CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD);\ngit remote add downstream codecommit::${AWS_REGION}://${RES_ACCOUNT_AWS_PROFILE}@${GIT_REPOSITORY};\ngit commit -am \"feat: init downstream\";\ngit push -u downstream ${CURRENT_BRANCH}:main ### default branch for CodePipeline can be configured in config/AppConfig.ts\n</code></pre>"},{"location":"developer_guides/vcs_codecommit.html#changing-default-branch","title":"Changing default branch","text":"<p>You can change the default branch which is picked up by the CodePipeline to trigger the pipeline with the following code snippet (during the pipeline definition):</p> <pre><code>import { BasicRepositoryProvider, PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst pipeline = PipelineBlueprint.builder()\n.repositoryProvider(new BasicRepositoryProvider({\n      repositoryType: 'CODECOMMIT',\n      branch: 'main',\n      name: 'my-repo',\n    }))\n...\n</code></pre>"},{"location":"developer_guides/vcs_codecommit.html#pointers-to-external-documentation","title":"Pointers to external documentation","text":"<ul> <li>Setup steps for HTTPS connections to AWS CodeCommit with git-remote-codecommit</li> </ul>"},{"location":"developer_guides/vcs_github.html","title":"GitHub Integration - AWS CodeStar Connection","text":"<p>To be able to use GitHub repositories in AWS CodePipeline with CDK CI/CD Wrapper, an AWS CodeStar Connection needs to be established. For more details go to the GitHub connection page.</p>"},{"location":"developer_guides/vcs_github.html#quick-setup","title":"Quick Setup","text":"<p>To create the AWS CodeStar Connection go to the desired AWS account where the AWS CodePipeline is planned to be placed and execute the following command.</p> <pre><code>aws codestar-connections create-connection --provider-type GitHub --profile $RES_ACCOUNT_AWS_PROFILE --region ${AWS_REGION} --connection-name MyConnection\n</code></pre> <p>This will initialize the connection from the AWS side. As a follow up go to the AWS CodeStar Connection on the Console and follow up the installation steps through the browser.</p> <p>Note: The user needs to have the following permission to establish the connection.</p> <ul> <li>Ownership permission on the GitHub Organization / Account</li> <li>IAM Permissions on the account</li> <li>codestar-connections:ListConnections</li> <li>codestar-connections:CreateConnection</li> <li>codestar-connections:UpdateConnectionInstallation</li> </ul>"},{"location":"developer_guides/vcs_github.html#changing-default-branch","title":"Changing default branch","text":"<p>You can change the default branch which is picked up by the CodePipeline to trigger the pipeline with the following code snippet (during the pipeline definition):</p> <pre><code>import { BasicRepositoryProvider, PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst pipeline = PipelineBlueprint.builder()\n.repositoryProvider(new BasicRepositoryProvider({\n      repositoryType: 'GITHUB',\n      branch: 'main',\n      name: 'my-repo',\n    }))\n...\n</code></pre>"},{"location":"developer_guides/vcs_github.html#known-issues","title":"Known Issues","text":"<ul> <li>Careful if you see a page like this when you open the Console  You might be using a wrong region or you don't have the right permissions.</li> <li>Make sure you have cookies enabled for your browser and you have the right permissions on both AWS and GitHub side or you could see something as shown in the screenshot below </li> </ul>"},{"location":"developer_guides/vcs_github.html#pointers-to-external-documentation","title":"Pointers to external documentation","text":"<ul> <li>GitHub connection</li> <li>Update a pending connection</li> </ul>"},{"location":"faqs/index.html","title":"Frequently asked questions","text":"<p>Below we list the most common issues you might encounter during the deployment using the CDK CI/CD Wrapper</p>"},{"location":"faqs/index.html#common-issues","title":"Common Issues","text":"<ul> <li>When using Cloud9 in the RES account and you want to deploy the code cross-account then you need to define the profiles for the DEV and INT Account as usual (adding them in the ~/.aws/config). The RES profile can be omitted in this case while doing the initial bootstrap, except for the DEV and INT or PROD stages where the profile is mandatory to establish a trust relationship between the RES account and the other environments (DEV/INT/PROD).</li> <li><code>when calling the PutParameter operation: The security token included in the request is invalid</code>: This usually happens if you use Cloud9. Make sure to disable AWS managed temporary credentials and give the full admin access to your Cloud9 Managed role in order to be able to execute everything necessary. </li> <li><code>Resource handler returned message: \"Policy contains a statement with one or more invalid principals. (Service: Kms, Status Code: 400, Request ID: a9f9e73b-cf2c-4862-9536-af92aa0ed656)\" (RequestToken: 949e9034-f910-7eb3-a4a2-427bc9e676b9, HandlerErrorCode: InvalidRequest)</code></li> <li>Make sure that the role you are trying to add to the policy exists in the given account.</li> <li>If you get <code>InvalidLocationConstraint</code> error during bucket creation, while executing <code>aws s3api create-bucket</code>   command, then consider removing <code>--create-bucket-configuration LocationConstraint</code> parameter. This error usually occurs   if the default region is the same as the one set in the LocationConstraint.</li> <li>If the pipeline fails with <code>AccessDeniedException</code> error or lacks any AWS resources, then this might be caused by the   wrong region setup. In this case some resources are deployed into another region. Check the region value that is set in   the <code>export_vars.sh</code> when you initially created the script or your cli env var <code>AWS_REGION</code>. The region should   be consistent across those files.</li> <li>Make sure the <code>CDK_QUALIFIER</code> meets the requirement of CDK - Qualifier must be an alphanumeric identifier of at most 10 characters</li> <li>If you have already deployed RES/DEV/INT and want to disable INT then please do the following:   <pre><code>export ACCOUNT_INT=\"-\"\nnpx dotenv-cli -- npm run cdk deploy --all --region ${AWS_REGION} --profile $RES_ACCOUNT_AWS_PROFILE --qualifier ${CDK_QUALIFIER}\n</code></pre>   After performing this please do not forget to delete your CloudFormation resources on the previous INT Account.</li> </ul>"},{"location":"getting_started/index.html","title":"Getting Started with the CDK CI/CD Wrapper","text":"<p>This guide gives you clear steps to set up and customize a Continuous Integration and Continuous Delivery (CI/CD) pipeline for your AWS CDK project. Following these steps will automate the build, testing, and delivery of your AWS CDK project, giving you a smooth workflow.</p>"},{"location":"getting_started/index.html#overview","title":"Overview","text":"<p>The CI/CD pipeline simplifies your development process, making sure your project undergoes thorough testing and validation before moving to different stages like development, integration, or production. It utilizes AWS services like AWS CodePipeline, AWS CodeBuild, and AWS CodeCommit/GitHub to manage the entire workflow seamlessly.</p>"},{"location":"getting_started/index.html#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have the following prerequisites in place:</p> <ol> <li>AWS Accounts: You will need access to multiple AWS accounts for different deployment stages (e.g., development, integration, production). If you prefer, you can also use a single account setup.</li> <li>AWS CLI Profiles: Configure AWS CLI profiles with appropriate permissions for each AWS account you plan to use.</li> <li>jq Command Line JSON Processor: Install the <code>jq</code> command-line JSON processor (version 1.5 or later).</li> <li>Docker: Install Docker (version 24.0.x or later).</li> <li>Python and Pipenv: If you plan to develop Python Lambda functions, ensure that you have Python (version 3.11 or later) and Pipenv (version 2023 or later) installed.</li> <li>Version Control System (VCS): The CI/CD pipeline provisions an AWS CodeCommit Git repository by default for hosting your project's source code. However, you can also choose to use your own GitHub repository.</li> </ol> <p>For more detailed information on prerequisites, refer to the Prerequisites documentation.</p> <p>Below we explain how to integrate the CDK CI/CD Wrapper into: - New CDK Project - Existing CDK Project</p>"},{"location":"getting_started/index.html#new-cdk-project","title":"New CDK project","text":"<p>You can apply the CDK CI/CD Wrapper to any of your existing CDK projects enable the CI/CD around your solution. If you don't have an existing CDK project then you can create one as shown in this guide step-by-step:</p> <pre><code>mkdir my-project\ncd my-project\nnpx aws-cdk@latest init app --language typescript\n</code></pre>"},{"location":"getting_started/index.html#installation","title":"Installation","text":"<ol> <li>Install the CDK CI/CD Wrapper pipeline package by running the following command:</li> </ol> <pre><code>npm i @cdklabs/cdk-cicd-wrapper @cdklabs/cdk-cicd-wrapper-cli\n</code></pre> <p>Note: If the <code>@cdklabs</code> scope is not available from the public NPM registry, you will need to configure a private NPM registry.</p>"},{"location":"getting_started/index.html#setup-local-environment","title":"Setup Local Environment","text":"<p>We suggest using the provided CLI tool to set up your local environment, as it simplifies the configuration process for the CI/CD pipeline. Simply follow these steps:</p> <ol> <li> <p>Run the <code>npx @cdklabs/cdk-cicd-wrapper-cli@latest configure</code> command and follow the instructions.</p> </li> <li> <p>After modifying the placeholders in the script,  source the variables:</p> </li> </ol> <pre><code>source .env\n</code></pre> <p>Note: The CLI Configure script supports the RES, DEV, INT, and PROD stages by default, but you can extend the list of stages as needed. If you plan to use a GitHub repository to host your project, you will need to know your AWS CodeStar Connection ARN.</p>"},{"location":"getting_started/index.html#bootstrap-your-stages","title":"Bootstrap your stages","text":"<p>The CDK CI/CD Wrapper uses the AWS CDK Toolkit with a cross-account trust relationship to deploy to multiple AWS accounts. This bootstrapping process must be established for each stage, and each account must have a trust relationship with the RES account..</p> <p>If you are reusing an existing CDK bootstrapping setup, you can skip this step. Otherwise, follow the instructions below to bootstrap your stages:</p> <ol> <li>Prepare the RES stage:</li> </ol> <pre><code>CDK_QUALIFIER=$(jq -r '.config.cdkQualifier' package.json)\nnpx dotenv-cli -- npm run cdk bootstrap -- --profile $RES_ACCOUNT_AWS_PROFILE --qualifier ${CDK_QUALIFIER} aws://${ACCOUNT_RES}/${AWS_REGION}\n</code></pre> <ol> <li>Prepare the DEV stage:</li> </ol> <pre><code>CDK_QUALIFIER=$(jq -r '.config.cdkQualifier' package.json)\nnpx dotenv-cli -- npm run cdk bootstrap -- --profile $DEV_ACCOUNT_AWS_PROFILE  --qualifier ${CDK_QUALIFIER} --cloudformation-execution-policies \\\narn:aws:iam::aws:policy/AdministratorAccess \\\n--trust ${ACCOUNT_RES} aws://${ACCOUNT_DEV}/${AWS_REGION}\n</code></pre> <ol> <li>Prepare the INT stage:</li> </ol> <pre><code>CDK_QUALIFIER=$(jq -r '.config.cdkQualifier' package.json)\nnpx dotenv-cli -- npm run cdk bootstrap -- --profile $INT_ACCOUNT_AWS_PROFILE --qualifier ${CDK_QUALIFIER} --cloudformation-execution-policies \\\narn:aws:iam::aws:policy/AdministratorAccess \\\n--trust ${ACCOUNT_RES} aws://${ACCOUNT_INT}/${AWS_REGION}\n</code></pre> <ol> <li>Prepare the PROD stage:</li> </ol> <pre><code>CDK_QUALIFIER=$(jq -r '.config.cdkQualifier' package.json)\nnpx dotenv-cli -- npm run cdk bootstrap -- --profile $PROD_ACCOUNT_AWS_PROFILE --qualifier ${CDK_QUALIFIER} --cloudformation-execution-policies \\\narn:aws:iam::aws:policy/AdministratorAccess \\\n--trust ${ACCOUNT_RES} aws://${ACCOUNT_PROD}/${AWS_REGION}\n</code></pre> <p>Note: Update the variables in the command with your actual account IDs and AWS region.</p>"},{"location":"getting_started/index.html#configure-gitignore","title":"Configure .gitignore","text":"<p>Ensure that the following lines are in your <code>.gitignore</code> file:</p> <ul> <li><code>.npmrc</code> (if you are using a private NPM repository)</li> <li><code>.env</code></li> </ul>"},{"location":"getting_started/index.html#existing-cdk-project","title":"Existing CDK project","text":"<p>To set up the CI/CD pipeline in your existing AWS CDK project, follow these steps:</p> <ol> <li>Install the CDK CI/CD Wrapper pipeline package by running the following command:</li> </ol> <pre><code>npm i @cdklabs/cdk-cicd-wrapper @cdklabs/cdk-cicd-wrapper-cli\n</code></pre> <p>Note: If the <code>@cdklabs</code> scope is not available from the public NPM registry, you will need to configure a private NPM registry.</p> <ol> <li> <p>Open your entry file, typically located at <code>bin/&lt;your-main-file&gt;.ts</code> (where <code>your-main-file</code> is the name of your root project directory).</p> </li> <li> <p>Include the <code>PipelineBlueprint.builder().synth(app)</code> statement in your entry file, like so:</p> </li> </ol> <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst app = new cdk.App();\n\nPipelineBlueprint.builder().synth(app);\n</code></pre> <p>This will deploy the CI/CD pipeline with its default configuration without deploying any stacks into the staging accounts.</p> <ol> <li>Optional: If you want to include additional stacks in the CI/CD pipeline, modify your entry file as follows:</li> </ol> <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { PipelineBlueprint, GlobalResources } from '@cdklabs/cdk-cicd-wrapper';\n\nconst app = new cdk.App();\n\nPipelineBlueprint.builder().addStack({\nprovide: (context) =&gt; {\n   // Create your stacks here\n   new YourStack(context.scope, `${context.blueprintProps.applicationName}YourStack`, {\n      applicationName: context.blueprintProps.applicationName,\n      stageName: context.stage,\n   });\n   new YourOtherStack(context.scope, `${context.blueprintProps.applicationName}YourOtherStack`, {\n      applicationQualifier: context.blueprintProps.applicationQualifier,\n      encryptionKey: context.get(GlobalResources.ENCRYPTION)!.kmsKey,\n   });\n}}).synth(app);\n</code></pre> <p>Note: Refer to the Developer Guide for more information on the <code>PipelineBlueprint</code>.</p> <ol> <li> <p>The CDK CI/CD Wrapper expects to have the <code>validate</code>, <code>lint</code>, <code>test</code>, <code>audit</code> scripts defined. If you are missing any of the <code>npm run</code> scripts (e.g., ), or want to use the provided CLI tool for one or more actions, you should add the following definitions to your <code>package.json</code> file:</p> </li> <li> <ol> <li>Adding cdk script (necessay when you run the <code>npm run cdk</code> and uses the local cdk version rather than the global one)   <pre><code> jq --arg key \"cdk\" --arg val \"npx aws-cdk@2.142.1\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\n</code></pre></li> </ol> </li> <li> <ol> <li>Adding validate script    <pre><code>jq --arg key \"validate\" --arg val \"cdk-cicd validate\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"validate:fix\" --arg val \"cdk-cicd validate --fix\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\n</code></pre></li> </ol> </li> <li> <ol> <li>Adding lint script, we recommend using eslint and you can initalise it    <pre><code>npm init @eslint/config\n\njq --arg key \"lint\" --arg val \"eslint . --ext .ts --max-warnings 0\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"lint:fix\" --arg val \"eslint . --ext .ts --fix\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\n</code></pre></li> </ol> </li> <li> <ol> <li>Adding audit scripts    <pre><code>npm install --save -D concurrently\njq --arg key \"audit\" --arg val \"concurrently 'npm:audit:*(\\!fix)'\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"audit:deps:nodejs\" --arg val \"cdk-cicd check-dependencies --npm\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"audit:deps:python\" --arg val \"cdk-cicd check-dependencies --python\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"audit:deps:security\" --arg val \"cdk-cicd security-scan --bandit --semgrep --shellcheck\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"audit:license\" --arg val \"npm run license\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"audit:fix:license\" --arg val \"npm run license:fix\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"license\" --arg val \"cdk-cicd license\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\njq --arg key \"license:fix\" --arg val \"cdk-cicd license --fix\" '.scripts[$key] = $val' package.json | jq . &gt; package.json.tmp; mv package.json.tmp package.json;\n</code></pre></li> </ol> </li> </ol> <pre><code>{\n  ...\n  \"scripts\": {\n    \"audit:deps:nodejs\": \"cdk-cicd check-dependencies --npm\",\n    \"audit:deps:python\": \"cdk-cicd check-dependencies --python\",\n    \"audit:fix:license\": \"npm run license:fix\",\n    \"audit:license\": \"npm run license\",\n    \"audit:scan:security\": \"cdk-cicd security-scan --bandit --semgrep --shellcheck --ci\",\n    \"audit\": \"npx concurrently 'npm:audit:*(!fix)'\",\n    \"cdk\": \"npx aws-cdk@2.142.1\",\n    \"license:fix\": \"cdk-cicd license --fix\",\n    \"license\": \"cdk-cicd license\",\n    \"lint:fix\": \"eslint . --ext .ts --fix\",\n    \"lint\": \"eslint . --ext .ts --max-warnings 0\",\n    \"test\": \"jest\",\n    \"validate:fix\": \"cdk-cicd validate --fix\",\n    \"validate\": \"cdk-cicd validate\",\n    ...\n  }\n  ...\n}\n</code></pre> <p>Note: If you are using <code>eslint</code> for linting, ensure that the configuration files are present or generate them with <code>npm init @eslint/config</code>.</p> <ol> <li>Before deploying, run the following commands to ensure your project is ready:</li> </ol> <pre><code>npm run validate:fix\nnpm run audit:fix:license\n</code></pre> <ul> <li><code>npm run validate:fix</code> will create the required <code>package-verification.json</code> file for you.</li> <li> <p><code>npm run audit:fix:license</code> will generate a valid Notice file for you.</p> </li> <li> <p>Deploy all the stacks by running the following command:</p> </li> </ul> <pre><code>npx dotenv-cli -- npm run cdk deploy -- --all --region ${AWS_REGION} --profile $RES_ACCOUNT_AWS_PROFILE --qualifier ${CDK_QUALIFIER}\n</code></pre> <p>Once the command finishes, the following CDK Stacks will be deployed into your RES Account:</p> <ul> <li>PipelineRepository: Responsible for either creating the CodeCommit repository  and setting up PullRequest automation for CodeGuru scanning and running a set of configured commands, or establishing the CodeStar connection between your AWS RES Account and the configured GitHub repository.</li> <li>SSMParameterStack: Responsible for creating parameters in the SSM Parameter Store, such as Account IDs.</li> <li>VPCStack: Responsible for enabling the running of the build stages of the pipeline in a VPC, with or without a proxy. By default, this stack is not created unless configured via <code>npx @cdklabs/cdk-cicd-wrapper-cli@latest configure</code>. Check here for more information on possible configurations.</li> <li>EncryptionStack: Responsible for creating the KMS Key used to encrypt all created CloudWatch Log Groups.</li> <li>PipelineStack: Responsible for creating the CodeCommit Repository and the CodePipeline with all the CodeBuild Steps.</li> </ul>"},{"location":"getting_started/index.html#configuring-continuous-integration","title":"Configuring Continuous Integration","text":"<p>The CI/CD pipeline comes with a set of predefined steps for checking the correctness of your source code:</p> <ul> <li><code>npm ci ##  Downloads the NPM dependencies.</code></li> <li><code>npm run validate ## Validates that the package-lock.json file has not been changed or corrupted.</code></li> <li><code>npm run audit ## Validates that the third-party dependencies are free from any known CVEs.</code></li> <li><code>npm run lint ## Checks source code linting.</code></li> <li><code>npm run build ## Builds the source code.</code></li> <li><code>npm run test ## Runs the included tests.</code></li> <li><code>npm run cdk synth ## Synthesizes the CDK projects and runs the CDK NAG.</code></li> </ul> <p>If all steps are finished successfully, the Continuous Integration (CI) part is considered complete.</p> <p>Note: The steps described above can be modified and extended. Additionally, any of the <code>npm run</code> steps can be disabled by changing the corresponding script definition to <code>true</code>. Use this approach only as a last resort.</p> <p>Note: A few additional steps are executed before the <code>npm run validate</code> step for configuring NPM registries and HTTP proxies.</p> <p>Note: The same steps are executed as part of the AWS CodeCommit's PullRequest review process.</p>"},{"location":"getting_started/index.html#deploy-changes-with-gitops","title":"Deploy Changes with GitOps","text":"<p>After the required infrastructure has been deployed, you can apply the GitOps practice to deploy changes.</p>"},{"location":"getting_started/index.html#push-the-local-repository-to-remote-codecommit","title":"Push the Local Repository to Remote (CodeCommit)","text":"<p>If you are using CodeCommit, you need to configure the downstream of the repository for deployment. On your local machine, install the <code>git-remote-codecommit</code> package using the following command:</p> <pre><code>sudo pip3 install git-remote-codecommit\n</code></pre> <p>Then, push your local repository to the remote CodeCommit repository:</p> <pre><code>CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD);\ngit remote add origin codecommit::${AWS_REGION}://${RES_ACCOUNT_AWS_PROFILE}@${GIT_REPOSITORY};\ngit commit -am \"feat: init origin\";\ngit push -u origin ${CURRENT_BRANCH}:main\n</code></pre> <p>Note: The default branch for the CI/CD pipeline can be configured.</p>"},{"location":"getting_started/index.html#push-the-local-repository-to-remote-github","title":"Push the Local Repository to Remote (GitHub)","text":"<p>If you are using GitHub, add the remote repository and push your local repository:</p> <pre><code>CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD);\ngit remote add origin git@github:${GIT_REPOSITORY}.git;\ngit commit -am \"feat: init origin\";\ngit push -u origin ${CURRENT_BRANCH}:main\n</code></pre> <p>Note: The <code>origin</code> remote alias might already be configured, in which case you need to change or replace it.</p> <p>Note: The default branch for the CI/CD pipeline can be configured.</p> <p>By following these steps, you have successfully set up and configured the CI/CD pipeline for your AWS CDK project. Your project will now be automatically built, tested, and deployed to the appropriate stages whenever changes are pushed to the remote repository.</p>"},{"location":"getting_started/migration_guide.html","title":"Migration Guide from CDK CI/CD Wrapper","text":"<p>This topic details the required steps to migrate existing Vanilla Pipeline projects to use the CDK CI/CD Wrapper.</p>"},{"location":"getting_started/prerequisites.html","title":"Prerequisites","text":"<p>This documentation provides a step-by-step guide for setting up the necessary prerequisites to work with AWS Lambda functions and CDK (Cloud Development Kit) pipelines. Before proceeding, ensure you have the following dependencies installed and configured correctly.</p>"},{"location":"getting_started/prerequisites.html#aws-account","title":"AWS Account","text":"<ul> <li>You need to have access to an AWS account for the respective environments (RES/DEV/INT/PROD).</li> </ul>"},{"location":"getting_started/prerequisites.html#operating-system","title":"Operating System","text":"<ul> <li>The setup can be performed on macOS, Linux, or Windows. If you're using Windows, it's recommended to use the Linux Subsystem for Windows (WSL) or a Cloud9 environment with Ubuntu Server 22.04 LTS Platform in your RES account.</li> </ul>"},{"location":"getting_started/prerequisites.html#terminal","title":"Terminal","text":"<ul> <li>You need to have a terminal emulator installed, such as Bash or ZSH.</li> </ul>"},{"location":"getting_started/prerequisites.html#docker","title":"Docker","text":"<ul> <li>Install Docker version 24.0.x or later.</li> </ul>"},{"location":"getting_started/prerequisites.html#aws-cli","title":"AWS CLI","text":"<ul> <li>Install the AWS Command Line Interface (AWS CLI) version 2 by following the instructions here.</li> </ul>"},{"location":"getting_started/prerequisites.html#aws-credentials-and-profiles","title":"AWS Credentials and Profiles","text":"<ul> <li>Configure your AWS credentials and profiles for each environment (RES/DEV/INT/PROD) by following the instructions here. The credentials should be stored in the <code>~/.aws/config</code> file.</li> </ul>"},{"location":"getting_started/prerequisites.html#nodejs-and-npm","title":"Node.js and NPM","text":"<ul> <li>Install Node.js version 18.18. or higher and NPM version 10.2. or higher.</li> </ul>"},{"location":"getting_started/prerequisites.html#jq-command-line-json-processor","title":"jq Command-line JSON Processor","text":"<ul> <li>Install the <code>jq</code> command-line JSON processor by following the instructions for your operating system here.</li> </ul>"},{"location":"getting_started/prerequisites.html#additional-dependencies-for-python-lambda-functions","title":"Additional Dependencies for Python Lambda Functions","text":"<p>If you're developing Python Lambda functions, you'll need the following additional dependencies:</p> <ul> <li>Install Python version 3.11 or later.</li> <li>Install Pipenv version 2023.* or later by following the instructions here.</li> </ul>"},{"location":"getting_started/projen.html","title":"Setting up a project with Projen","text":"<p>Projen is a tool that helps define and maintain complex project configurations through code. It allows you to generate project configuration files from a well-typed definition, making it easier to manage and maintain your project structure.</p>"},{"location":"getting_started/projen.html#prerequisites","title":"Prerequisites","text":"<p>Before getting started, ensure that you have the following prerequisites installed:</p> <ul> <li>Node.js (version 16.x or later)</li> <li>npm (comes bundled with Node.js)</li> </ul> <p>Projen doesn't need to be installed separately. You will be using <code>npx</code> to run Projen, which takes care of all the required setup steps.</p>"},{"location":"getting_started/projen.html#step-1-initialize-a-new-project","title":"Step 1: Initialize a new project","text":"<p>Follow these steps to initialize a new project using Projen:</p> <ol> <li>Open your terminal or command prompt.</li> <li>Navigate to the directory where you want to create your new project.</li> <li>Run the following command to initialize a new CDK CI/CD Wrapper project:</li> </ol> <pre><code>npx projen@latest new awscdk-app-ts --no-git --deps @cdklabs/cdk-cicd-wrapper-projen\n</code></pre> <p>This command initializes a new AWS CDK TypeScript app project with the <code>@cdklabs/cdk-cicd-wrapper-projen</code> dependency.</p> <ol> <li>Open the <code>.projenrc.ts</code> file and add the following code:</li> </ol> <pre><code>import { awscdk } from 'projen';\nimport { CdkCICDWrapper } from '@cdklabs/cdk-cicd-wrapper-projen';\n\nconst project = new awscdk.AwsCdkTypeScriptApp({\n  cdkVersion: '2.1.0',\n  defaultReleaseBranch: 'main',\n  deps: ['@cdklabs/cdk-cicd-wrapper'],\n  name: 'project',\n  projenrcTs: true,\n});\n\n//@ts-ignore Projen Versions can be different during the upgrade process and would resolve complains about assignability issues.\nnew CdkCICDWrapper(project, {\n  cdkQualifier: 'wrapper',\n  repositoryName: 'projen-sample-wrapper',\n  repositoryType: 'CODECOMMIT',\n});\n\nproject.synth();\n</code></pre> <p>This code configures the project with the necessary settings for the AWS CDK and the <code>CdkCICDWrapper</code> component.</p> <ol> <li> <p>Execute the <code>npx projen</code> command to enable the project.</p> </li> <li> <p>Before deploying, run the following commands to ensure your project is ready:</p> </li> </ol> <pre><code>npm run validate -- --fix\nnpm run license -- --fix\n</code></pre> <ul> <li><code>npm run validate -- --fix</code> will create the required <code>package-verification.json</code> file for you.</li> <li><code>npm run license -- --fix</code> will generate a valid Notice file for you.</li> </ul>"},{"location":"getting_started/projen.html#step-2-configure-stacks","title":"Step 2: Configure stacks","text":"<p>The <code>PipelineBlueprint</code> component provided by the <code>{{ npm_pipeline }}</code> package allows you to define and configure the stacks for your application. Here's an example of how you can configure your stacks:</p> <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst app = new cdk.App();\n\nPipelineBlueprint.builder().addStack({\n  provide: (context) =&gt; {\n    // Create your stacks here\n    new YourStack(context.scope, `${context.blueprintProps.applicationName}YourStack`, {\n      applicationName: context.blueprintProps.applicationName,\n      stageName: context.stage,\n    });\n    new YourOtherStack(context.scope, `${context.blueprintProps.applicationName}YourOtherStack`, {\n      applicationQualifier: context.blueprintProps.applicationQualifier,\n      encryptionKey: context.get(GlobalResources.Encryption)!.kmsKey,\n    });\n  }\n}).synth(app);\n</code></pre> <p>Note: Refer to the Developer Guide for more information on the <code>PipelineBlueprint</code> component and how to configure your stacks.</p>"},{"location":"getting_started/projen.html#step-3-configure-environment-variables-create-env-file","title":"Step 3: Configure environment variables / create .env file","text":"<p>The CDK CI/CD Wrapper uses environment variables to store sensitive information and configuration settings. The <code>CdkCICDWrapper</code> component creates a sample <code>.env</code> file in the root directory of your project and defines the necessary variables there. You must fill out the values for these variables.</p> <p>This file is created once, and you must maintain it manually as needed.</p>"},{"location":"getting_started/projen.html#step-4-bootstrap-your-stages","title":"Step 4: Bootstrap your stages","text":"<p>The CDK CI/CD Wrapper uses the AWS CDK Toolkit with a cross-account trust relationship to deploy to multiple AWS accounts. This bootstrapping process must be established for each stage, and each account must have a trust relationship with the RES account.</p> <p>If you are reusing an existing CDK bootstrapping setup, you can skip this step. Otherwise, follow these instructions to bootstrap your stages:</p> <ol> <li>Prepare the RES stage:</li> </ol> <pre><code>npm run bootstrap RES\n</code></pre> <ol> <li>Prepare the DEV stage:</li> </ol> <pre><code>npm run bootstrap DEV\n</code></pre> <ol> <li>Prepare the INT stage:</li> </ol> <pre><code>npm run bootstrap INT\n</code></pre> <ol> <li>Prepare the PROD stage:</li> </ol> <pre><code>npm run bootstrap PROD\n</code></pre> <p>Note: The stages have to be defined in the <code>.projenrc.ts</code> file <code>CdkCICDWrapperOptions.stages</code> variable.</p>"},{"location":"getting_started/projen.html#step-5-deploy-the-pipeline","title":"Step 5: Deploy the pipeline","text":"<p>Once you have completed the previous steps, you can deploy the pipeline:</p> <ol> <li>In your terminal or command prompt, navigate to the root directory of your project.</li> <li>Run the following command to deploy the pipeline:</li> </ol> <pre><code>npm run deploy\n</code></pre> <p>This command will prompt you to confirm the deployment and then create the necessary resources for your pipeline in AWS.</p>"},{"location":"getting_started/projen.html#step-6-push-your-changes-to-the-git-repository","title":"Step 6: Push your changes to the git repository","text":"<p>After the deployment is complete, Projen will automatically trigger the pipeline and begin the process of building, testing, and deploying your application infrastructure based on the defined stages. Push your changes to the Git repository to start the pipeline process.</p>"},{"location":"getting_started/projen.html#conclusion","title":"Conclusion","text":"<p>Congratulations! You have successfully set up a project with Projen and configured a pipeline for building and deploying your cloud-based application infrastructure. This documentation provides an overview of the process and guides you through the necessary steps.</p> <p>If you need further assistance or have any questions, please refer to the official Projen documentation or reach out to the project maintainers for support.</p>"},{"location":"getting_started/projen_with_taskfile.html","title":"Setting Up a Project with Projen","text":"<p>Projen is a tool that helps define and maintain complex project configurations through code. It allows you to generate project configuration files from a well-typed definition, making it easier to manage and maintain your project structure.</p>"},{"location":"getting_started/projen_with_taskfile.html#prerequisites","title":"Prerequisites","text":"<p>Before getting started, ensure that you have the following prerequisites installed:</p> <ul> <li>Node.js (version 16.x or later)</li> <li>npm (comes bundled with Node.js)</li> </ul> <p>Projen doesn't need to be installed separately. You will be using <code>npx</code> to run Projen, which takes care of all the required steps of the setup.</p>"},{"location":"getting_started/projen_with_taskfile.html#step-1-initialize-a-new-project","title":"Step 1: Initialize a new project","text":"<p>Follow these steps to initialize a new project using Projen:</p> <ol> <li>Open your terminal or command prompt.</li> <li>Navigate to the directory where you want to create your new project.</li> <li>Run the following command to initialize a new CDK CI/CD Wrapper project:</li> </ol> <pre><code>npx projen@latest new awscdk-app-ts --no-git --deps @cdklabs/cdk-cicd-wrapper-projen\n</code></pre> <p>This command initializes a new AWS CDK TypeScript app project with the <code>@cdklabs/cdk-cicd-wrapper-projen</code> dependency.</p> <ol> <li>Open the <code>.projenrc.ts</code> file and add the following code:</li> </ol> <pre><code>import { awscdk } from 'projen';\nimport { CdkCICDWrapper } from '@cdklabs/cdk-cicd-wrapper-projen';\n\nconst project = new awscdk.AwsCdkTypeScriptApp({\n  cdkVersion: '2.1.0',\n  defaultReleaseBranch: 'main',\n  deps: ['@cdklabs/cdk-cicd-wrapper'],\n  name: 'project',\n  projenrcTs: true,\n});\n\n//@ts-ignore Projen Versions can be different during the upgrade process and would resolve complains about assignability issues.\nnew CdkCICDWrapper(project, {\n  cdkQualifier: 'wrapper',\n  repositoryName: 'projen-sample-wrapper',\n  repositoryType: 'CODECOMMIT',\n  taskfile: true,\n});\n\nproject.synth();\n</code></pre> <p>This code configures the project with the necessary settings for the AWS CDK and the <code>CdkCICDWrapper</code> component.</p> <ol> <li> <p>Execute the <code>npx projen</code> command to enable the project.</p> </li> <li> <p>Before deploying, run the following commands to ensure your project is ready:</p> </li> </ol> <pre><code>task prepare\n</code></pre>"},{"location":"getting_started/projen_with_taskfile.html#step-2-configure-stacks","title":"Step 2: Configure stacks","text":"<p>The <code>PipelineBlueprint</code> component provided by the <code>{{ npm_pipeline }}</code> package allows you to define and configure the stacks for your application. Here's an example of how you can configure your stacks:</p> <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { PipelineBlueprint } from '@cdklabs/cdk-cicd-wrapper';\n\nconst app = new cdk.App();\n\nPipelineBlueprint.builder().addStack({\n  provide: (context) =&gt; {\n    // Create your stacks here\n    new YourStack(context.scope, `${context.blueprintProps.applicationName}YourStack`, {\n      applicationName: context.blueprintProps.applicationName,\n      stageName: context.stage,\n    });\n    new YourOtherStack(context.scope, `${context.blueprintProps.applicationName}YourOtherStack`, {\n      applicationQualifier: context.blueprintProps.applicationQualifier,\n      encryptionKey: context.get(GlobalResources.Encryption)!.kmsKey,\n    });\n  }\n}).synth(app);\n</code></pre> <p>Note: Refer to the Developer Guide for more information on the <code>PipelineBlueprint</code> component and how to configure your stacks.</p>"},{"location":"getting_started/projen_with_taskfile.html#step-3-configure-environment-variables-create-env-file","title":"Step 3: Configure environment variables / create .env file","text":"<p>The CDK CI/CD Wrapper uses environment variables to store sensitive information and configuration settings. The <code>CdkCICDWrapper</code> component creates a sample <code>.env</code> file in the root directory of your project and defines the necessary variables there. You must fill out the values for these variables.</p> <p>This file is created once, and you must maintain it manually as needed.</p>"},{"location":"getting_started/projen_with_taskfile.html#step-4-bootstrap-your-stages","title":"Step 4: Bootstrap your stages","text":"<p>The CDK CI/CD Wrapper uses the AWS CDK Toolkit with a cross-account trust relationship to deploy to multiple AWS accounts. This bootstrapping process must be established for each stage, and each account must have a trust relationship with the RES account.</p> <p>If you are reusing an existing CDK bootstrapping setup, you can skip this step. Otherwise, follow these instructions to bootstrap your stages:</p> <pre><code>task bootstrap\n</code></pre> <p>Note: The stages have to be defined in the <code>.env</code> file in the <code>STAGES_ENABLED</code> variable.</p>"},{"location":"getting_started/projen_with_taskfile.html#step-5-deploy-the-pipeline","title":"Step 5: Deploy the pipeline","text":"<p>Once you have completed the previous steps, you can deploy the pipeline:</p> <ol> <li>In your terminal or command prompt, navigate to the root directory of your project.</li> <li>Run the following command to deploy the pipeline:</li> </ol> <pre><code>task deploy\n</code></pre> <p>This command will prompt you to confirm the deployment and then create the necessary resources for your pipeline in AWS.</p>"},{"location":"getting_started/projen_with_taskfile.html#step-6-push-your-changes-to-the-git-repository","title":"Step 6: Push your changes to the git repository","text":"<p>After the deployment is complete, Projen will automatically trigger the pipeline and begin the process of building, testing, and deploying your application infrastructure based on the defined stages. Push your changes to the Git repository to start the pipeline process.</p>"},{"location":"getting_started/projen_with_taskfile.html#conclusion","title":"Conclusion","text":"<p>Congratulations! You have successfully set up a project with Projen and configured a pipeline for building and deploying your cloud-based application infrastructure. This documentation provides an overview of the process and guides you through the necessary steps.</p> <p>If you need further assistance or have any questions, please refer to the official Projen documentation or reach out to the project maintainers for support.</p>"},{"location":"overview/index.html","title":"CDK CI/CD Wrapper","text":""},{"location":"overview/index.html#introduction","title":"Introduction","text":"<p>The CDK CI/CD Wrapper is a comprehensive CI/CD platform for AWS CDK-based applications and solutions. It provides a standardized and easy-to-use Continuous Integration solution leveraging AWS CodeBuild. The process ensures that the codebase follows code style guidelines, can be successfully compiled, runs supplied tests, and performs various quality checks related to security.</p> <p>Once the codebase successfully passes the quality gates, the CDK CI/CD Wrapper enables Continuous Deployment of the solution across multiple stages, such as DEV, INT, and PROD. For each stage, you can configure pre and post deployment steps to hook in various activities like integration and end-to-end testing. Additionally, you can have post-deployment steps to finalize the deployment activities.</p>"},{"location":"overview/index.html#why-use-the-cdk-cicd-wrapper","title":"Why use the CDK CI/CD Wrapper?","text":"<p>Setting up CI/CD pipelines for AWS CDK-based projects is a recurring and time-consuming activity for many teams. This process often results in different \"flavors\" of pipelines, leading to duplicated effort and increased maintenance and governance complexity.</p> <p>The CI/CD process setup is often thought of as a one-time activity, but in reality, it is a continuous process that needs to be done systematically.</p> <p>The CDK CI/CD Wrapper can address these issues and drastically reduce the effort needed to maintain and develop AWS CDK-based solutions, allowing you to focus on your solution while it takes care of the CI/CD process.</p> <p>Here are some key features provided by the CDK CI/CD Wrapper:</p> <ul> <li> Customizable CI steps to meet project requirements</li> <li> Integration of various security scanning tools</li> <li> Multi-staged Continuous Deployment process</li> <li> Flexible definition of stages, with the ability to extend the default (DEV/INT/PROD) stages with custom stages like EXP</li> <li> Separate stack deployment specification for each stage</li> <li> Pre/Post deploy hooks during the deployment in each stage (DEV/INT/PROD)</li> <li> PRE -&gt; Unit Tests</li> <li> POST -&gt; Functional Tests, Load Testing</li> <li> Automated Open Source License checking (with a provided list of licenses that should not be present in your PRODUCTION workloads)</li> <li> Centralized storage of compliance logs in S3 buckets pre-configured on a per-stage/environment basis</li> <li> Build Lambda Layers for Python and scan dependencies in the CI/CD (in case of CVE findings, block the pipeline)</li> </ul> <p>These features can be used independently in any project as part of the CDK CI/CD Wrapper CLI, even if your project is not based on AWS CDK.</p>"},{"location":"overview/index.html#cicd-process-overview","title":"CI/CD Process Overview","text":"<p>The CI/CD process in the CDK CI/CD Wrapper establishes the following:</p> <ol> <li>Changes are committed to the Git repository in a branch, and a Pull Request (PR) is created for the <code>main</code> branch.</li> <li>The PR is reviewed, approved, and merged into the <code>main</code> branch.</li> <li>For AWS CodeCommit repositories, the CDK CI/CD Wrapper provides out-of-the-box automatic PR checks.</li> <li>Once the codebase is merged into <code>main</code>, an AWS CodePipeline is triggered to execute the CI/CD process:</li> <li>Build: This is the Continuous Integration step, which executes the build, test, lint, and audit actions to ensure code quality and security before deployment to any stages.</li> <li>Synthesize: This step executes <code>cdk synth</code> and runs the CDK Nag to promote infrastructure best practices.</li> <li>Update RES: This step updates the infrastructure elements in the RES account with the AWS CloudFormation Service.</li> <li>Update DEV: This step updates the infrastructure elements in the DEV account with the AWS CloudFormation Service.</li> <li>Update INT: This step updates the infrastructure elements in the INT account with the AWS CloudFormation Service.</li> <li>Update PROD: This step updates the infrastructure elements in the PROD account with the AWS CloudFormation Service.</li> </ol>"},{"location":"overview/index.html#infrastructure-elements","title":"Infrastructure Elements","text":"<p>The CDK CI/CD Wrapper architecture is based on using DevOps services provided by AWS to deliver the CI/CD solution.</p> <p></p> <p>You can read more about these elements in the Developer Guide.</p>"},{"location":"overview/index.html#getting-started","title":"Getting Started","text":"<p>If you are eager to start using the CDK CI/CD Wrapper, check out the Getting Started guides.</p>"},{"location":"overview/index.html#contributing-to-the-cdk-cicd-wrapper","title":"Contributing to the CDK CI/CD Wrapper","text":"<p>The team encourages you to contribute to make it an even better framework. For details, see contributing.</p>"}]}